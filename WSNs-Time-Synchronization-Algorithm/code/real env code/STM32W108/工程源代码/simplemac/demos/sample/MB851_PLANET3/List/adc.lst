###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     05/Jul/2014  18:37:57 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  I:\实验4 无线传感器节点多点通信实验\工程源代码\hal\micro #
#                    \cortexm3\adc.c                                          #
#    Command line =  "I:\实验4 无线传感器节点多点通信实验\工程源代码\hal\micr #
#                    o\cortexm3\adc.c" -D BOARD_MB851 -D                      #
#                    "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\""  #
#                    -D "BOARD_HEADER=\"hal/micro/cortexm3/stm32w108/board.h\ #
#                    "" -D CORTEXM3 -D CORTEXM3_STM32W108 -D PHY_STM32W108XX  #
#                    -D DISABLE_WATCHDOG -D PLANET_ROLE -D BOARD_MB851 -D     #
#                    "__SOURCEFILE__=\"adc.c\"" -lC "I:\实验4                 #
#                    无线传感器节点多点通信实验\工程源代码\simplemac\demos\sa #
#                    mple\MB851_PLANET3\List\" --diag_suppress Pa050 -o       #
#                    "I:\实验4 无线传感器节点多点通信实验\工程源代码\simplema #
#                    c\demos\sample\MB851_PLANET3\Obj\" --debug               #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "D:\study soft\IAR6.10\IARsoft\arm\INC\c\D #
#                    Lib_Config_Normal.h" -I "I:\实验4                        #
#                    无线传感器节点多点通信实验\工程源代码\hal\micro\cortexm3 #
#                    \" -I "I:\实验4 无线传感器节点多点通信实验\工程源代码\si #
#                    mplemac\demos\sample\..\..\..\simplemac\include\" -I     #
#                    "I:\实验4 无线传感器节点多点通信实验\工程源代码\simplema #
#                    c\demos\sample\..\..\..\" -I "I:\实验4                   #
#                    无线传感器节点多点通信实验\工程源代码\simplemac\demos\sa #
#                    mple\..\..\..\hal\" -I "I:\实验4                         #
#                    无线传感器节点多点通信实验\工程源代码\simplemac\demos\sa #
#                    mple\..\..\..\HAL\MICRO\CORTEXM3\STM32W108\" -I          #
#                    "I:\实验4 无线传感器节点多点通信实验\工程源代码\simplema #
#                    c\demos\sample\..\..\..\simplemac\" -I "I:\实验4         #
#                    无线传感器节点多点通信实验\工程源代码\simplemac\demos\sa #
#                    mple\..\..\..\shared\" -Ohz --use_c++_inline             #
#    List file    =  I:\实验4 无线传感器节点多点通信实验\工程源代码\simplemac #
#                    \demos\sample\MB851_PLANET3\List\adc.lst                 #
#    Object file  =  I:\实验4 无线传感器节点多点通信实验\工程源代码\simplemac #
#                    \demos\sample\MB851_PLANET3\Obj\adc.o                    #
#                                                                             #
#                                                                             #
###############################################################################

I:\实验4 无线传感器节点多点通信实验\工程源代码\hal\micro\cortexm3\adc.c
      1          /** @file adc.c
      2           * @brief  ADC HAL functions
      3           *
      4           * <!--(C) COPYRIGHT 2010 STMicroelectronics. All rights reserved.        -->
      5           */
      6          #include PLATFORM_HEADER
      7          #include "hal/error.h"
      8          #include "hal/hal.h"
      9          #include "hal/micro/adc.h"
     10          
     11          
     12          #if (NUM_ADC_USERS > 8)
     13            #error NUM_ADC_USERS must not be greater than 8, or int8u variables in adc.c must be changed
     14          #endif
     15          

   \                                 In section .bss, align 4
     16          static int16u adcData;             // conversion result written by DMA
     17          static int8u adcPendingRequests;   // bitmap of pending requests
   \                     adcPendingRequests:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \   00000004                      DS8 2
   \   00000006                      DS8 2
   \   00000008                      DS8 2
   \   0000000A                      DS8 2
   \   0000000C                      DS8 8
   \   00000014                      DS8 8
   \   0000001C                      DS8 2
     18          volatile static int8u adcPendingConversion; // id of pending conversion
     19          static int8u adcReadingValid;      // bitmap of valid adcReadings
     20          static int16u adcReadings[NUM_ADC_USERS];
     21          static int16u adcConfig[NUM_ADC_USERS];
     22          static boolean adcCalibrated;
     23          static int16s Nvss;
     24          static int16s Nvdd;
     25          /* Modified the original ADC driver for enabling the ADC extended range mode required for 
     26             supporting the STLM20 temperature sensor.
     27             NOTE: 
     28             The ADC extended range is inaccurate due to the high voltage mode bug of the general purpose ADC 
     29             (see STM32W108 errata). As consequence, it is not reccomended to use this ADC driver for getting
     30             the temperature values 
     31          */
     32          #ifdef ENABLE_ADC_EXTENDED_RANGE_BROKEN
     33          static int16s Nvref;
     34          static int16s Nvref2;
     35          #endif /* ENABLE_ADC_EXTENDED_RANGE_BROKEN */
     36          static int16u adcStaticConfig;
     37          

   \                                 In section .text, align 2, keep-with-next
     38          void halAdcSetClock(boolean slow)
     39          {
     40            if (slow) {
   \                     halAdcSetClock:
   \   00000000   ....               LDR.N    R1,??DataTable12
   \   00000002   0A89               LDRH     R2,[R1, #+8]
   \   00000004   0028               CMP      R0,#+0
   \   00000006   12BF               ITEE     NE 
   \   00000008   42F00400           ORRNE    R0,R2,#0x4
   \   0000000C   4FF6FB70           MOVWEQ   R0,#+65531
   \   00000010   1040               ANDEQ    R0,R0,R2
     41              adcStaticConfig |= ADC_1MHZCLK_MASK;
     42            } else {
     43              adcStaticConfig &= ~ADC_1MHZCLK_MASK;
   \   00000012   0881               STRH     R0,[R1, #+8]
     44            }
     45          }
   \   00000014   7047               BX       LR               ;; return
     46          

   \                                 In section .text, align 2, keep-with-next
     47          void halAdcSetRange(boolean high)
     48          {
     49            if (high) {
   \                     halAdcSetRange:
   \   00000000   ....               LDR.N    R1,??DataTable12
   \   00000002   0A89               LDRH     R2,[R1, #+8]
   \   00000004   0028               CMP      R0,#+0
   \   00000006   12BF               ITEE     NE 
   \   00000008   42F4C050           ORRNE    R0,R2,#0x1800
   \   0000000C   4EF2FF70           MOVWEQ   R0,#+59391
   \   00000010   1040               ANDEQ    R0,R0,R2
     50              adcStaticConfig |= (ADC_HVSELP_MASK | ADC_HVSELN_MASK);
     51            } else {
     52              adcStaticConfig &= ~(ADC_HVSELP_MASK | ADC_HVSELN_MASK);
   \   00000012   0881               STRH     R0,[R1, #+8]
     53            }
     54          }
   \   00000014   7047               BX       LR               ;; return
     55          

   \                                 In section .text, align 2, keep-with-next
     56          boolean halAdcGetClock(void)
     57          {
     58            /* Fix original function code */
     59            return (adcStaticConfig & ADC_1MHZCLK_MASK) ? TRUE : FALSE;
   \                     halAdcGetClock:
   \   00000000   ....               LDR.N    R0,??DataTable12
   \   00000002   0089               LDRH     R0,[R0, #+8]
   \   00000004   0006               LSLS     R0,R0,#+24
   \   00000006   800E               LSRS     R0,R0,#+26
   \   00000008   00F00100           AND      R0,R0,#0x1
   \   0000000C   7047               BX       LR               ;; return
     60          }
     61          

   \                                 In section .text, align 2, keep-with-next
     62          boolean halAdcGetRange(void)
     63          {
     64            /* Fix original function code */
     65            return (adcStaticConfig & ((ADC_HVSELP_MASK | ADC_HVSELN_MASK))) ? TRUE : FALSE;
   \                     halAdcGetRange:
   \   00000000   ....               LDR.N    R0,??DataTable12
   \   00000002   0089               LDRH     R0,[R0, #+8]
   \   00000004   10F4C050           ANDS     R0,R0,#0x1800
   \   00000008   18BF               IT       NE 
   \   0000000A   0120               MOVNE    R0,#+1
   \   0000000C   C0B2               UXTB     R0,R0
   \   0000000E   7047               BX       LR               ;; return
     66          }
     67          
     68          
     69          
     70          // Define a channel field that combines ADC_MUXP and ADC_MUXN
     71          #define ADC_CHAN        (ADC_MUXP | ADC_MUXN)
     72          #define ADC_CHAN_BIT    ADC_MUXN_BIT
     73          

   \                                 In section .text, align 4, keep-with-next
     74          void halAdcIsr(void)
     75          {
   \                     halAdcIsr:
   \   00000000   70B5               PUSH     {R4-R6,LR}
     76            int8u i;
     77            int8u conversion = adcPendingConversion; //fix 'volatile' warning; costs no flash
   \   00000002   ....               LDR.N    R0,??DataTable12
   \   00000004   4278               LDRB     R2,[R0, #+1]
     78          
     79            // make sure data is ready and the desired conversion is valid
     80            if ( (INT_ADCFLAG & INT_ADCULDFULL)
     81                  && (conversion < NUM_ADC_USERS) ) {
   \   00000006   ....               LDR.N    R1,??DataTable12_1  ;; 0x4000a810
   \   00000008   0B68               LDR      R3,[R1, #+0]
   \   0000000A   5B07               LSLS     R3,R3,#+29
   \   0000000C   24D5               BPL.N    ??halAdcIsr_0
   \   0000000E   032A               CMP      R2,#+3
   \   00000010   22DA               BGE.N    ??halAdcIsr_0
     82              adcReadings[conversion] = adcData;
   \   00000012   00EB4203           ADD      R3,R0,R2, LSL #+1
   \   00000016   8488               LDRH     R4,[R0, #+4]
   \   00000018   9C81               STRH     R4,[R3, #+12]
     83              adcReadingValid |= BIT(conversion); // mark the reading as valid
   \   0000001A   0123               MOVS     R3,#+1
   \   0000001C   8478               LDRB     R4,[R0, #+2]
   \   0000001E   03FA02F2           LSL      R2,R3,R2
   \   00000022   2243               ORRS     R2,R2,R4
   \   00000024   8270               STRB     R2,[R0, #+2]
     84              // setup the next conversion if any
     85              if (adcPendingRequests) {
   \   00000026   0278               LDRB     R2,[R0, #+0]
   \   00000028   ....               LDR.N    R4,??DataTable12_2  ;; 0x4000d004
   \   0000002A   92B1               CBZ.N    R2,??halAdcIsr_1
     86                for (i = 0; i < NUM_ADC_USERS; i++) {
   \   0000002C   0025               MOVS     R5,#+0
     87                  if (BIT(i) & adcPendingRequests) {
   \   0000002E   D607               LSLS     R6,R2,#+31
   \   00000030   08D5               BPL.N    ??halAdcIsr_2
     88                    adcPendingConversion = i;     // set pending conversion
   \                     ??halAdcIsr_3:
   \   00000032   4570               STRB     R5,[R0, #+1]
     89                    adcPendingRequests ^= BIT(i); //clear request: conversion is starting
   \   00000034   AB40               LSLS     R3,R3,R5
   \   00000036   5A40               EORS     R2,R3,R2
   \   00000038   0270               STRB     R2,[R0, #+0]
     90                    ADC_CFG = adcConfig[i]; 
   \   0000003A   00EB4500           ADD      R0,R0,R5, LSL #+1
   \   0000003E   808A               LDRH     R0,[R0, #+20]
   \   00000040   2060               STR      R0,[R4, #+0]
     91                    break; //conversion started, so we're done here (only one at a time)
   \   00000042   09E0               B.N      ??halAdcIsr_0
     92                  }
   \                     ??halAdcIsr_2:
   \   00000044   0125               MOVS     R5,#+1
   \   00000046   9607               LSLS     R6,R2,#+30
   \   00000048   F3D4               BMI.N    ??halAdcIsr_3
   \   0000004A   0225               MOVS     R5,#+2
   \   0000004C   5607               LSLS     R6,R2,#+29
   \   0000004E   F0D4               BMI.N    ??halAdcIsr_3
   \   00000050   02E0               B.N      ??halAdcIsr_0
     93                }
     94              } else {                                // no conversion to do
     95                ADC_CFG = 0;                          // disable adc
   \                     ??halAdcIsr_1:
   \   00000052   2260               STR      R2,[R4, #+0]
     96                adcPendingConversion = NUM_ADC_USERS; //nothing pending, so go "idle"
   \   00000054   0322               MOVS     R2,#+3
   \   00000056   4270               STRB     R2,[R0, #+1]
     97              }
     98            }
     99            INT_ADCFLAG = 0xFFFF;
   \                     ??halAdcIsr_0:
   \   00000058   4FF6FF70           MOVW     R0,#+65535
   \   0000005C   0860               STR      R0,[R1, #+0]
    100            asm("DMB");
   \   0000005E   BFF35F8F           DMB              
    101          }
   \   00000062   70BD               POP      {R4-R6,PC}       ;; return
    102          
    103          // An internal support routine called from functions below.
    104          // Returns the user number of the started conversion, or NUM_ADC_USERS
    105          // otherwise.

   \                                 In section .text, align 2, keep-with-next
    106          ADCUser startNextConversion()
    107          {
   \                     startNextConversion:
   \   00000000   70B5               PUSH     {R4-R6,LR}
    108            int8u i;
    109            
    110            ATOMIC (
    111              // start the next requested conversion if any
    112              if (adcPendingRequests && !(ADC_CFG & ADC_ENABLE)) {
    113                for (i = 0; i < NUM_ADC_USERS; i++) {
    114                  if ( BIT(i) & adcPendingRequests) {
    115                    adcPendingConversion = i;     // set pending conversion
    116                    adcPendingRequests ^= BIT(i); // clear request
    117                    ADC_CFG = adcConfig[i];       // set the configuration to desired
    118                    INT_ADCFLAG = 0xFFFF;
    119                    INT_CFGSET = INT_ADC;
    120                  }
    121                }
    122              } else {
    123                i = NUM_ADC_USERS;
    124              }
    125            )
   \   00000002   ........           BL       _disableBasePri
   \   00000006   ....               LDR.N    R1,??DataTable12
   \   00000008   0A78               LDRB     R2,[R1, #+0]
   \   0000000A   DAB1               CBZ.N    R2,??startNextConversion_0
   \   0000000C   ....               LDR.N    R3,??DataTable12_2  ;; 0x4000d004
   \   0000000E   1C68               LDR      R4,[R3, #+0]
   \   00000010   E407               LSLS     R4,R4,#+31
   \   00000012   17D4               BMI.N    ??startNextConversion_0
   \   00000014   0024               MOVS     R4,#+0
   \                     ??startNextConversion_1:
   \   00000016   0125               MOVS     R5,#+1
   \   00000018   A540               LSLS     R5,R5,R4
   \   0000001A   EEB2               UXTB     R6,R5
   \   0000001C   1642               TST      R6,R2
   \   0000001E   0DD0               BEQ.N    ??startNextConversion_2
   \   00000020   4C70               STRB     R4,[R1, #+1]
   \   00000022   6A40               EORS     R2,R5,R2
   \   00000024   01EB4405           ADD      R5,R1,R4, LSL #+1
   \   00000028   AD8A               LDRH     R5,[R5, #+20]
   \   0000002A   1D60               STR      R5,[R3, #+0]
   \   0000002C   ....               LDR.N    R5,??DataTable12_1  ;; 0x4000a810
   \   0000002E   4FF6FF76           MOVW     R6,#+65535
   \   00000032   2E60               STR      R6,[R5, #+0]
   \   00000034   ....               LDR.N    R5,??DataTable12_3  ;; 0xe000e100
   \   00000036   4FF40066           MOV      R6,#+2048
   \   0000003A   2E60               STR      R6,[R5, #+0]
   \                     ??startNextConversion_2:
   \   0000003C   641C               ADDS     R4,R4,#+1
   \   0000003E   032C               CMP      R4,#+3
   \   00000040   E9DB               BLT.N    ??startNextConversion_1
   \   00000042   00E0               B.N      ??startNextConversion_3
   \                     ??startNextConversion_0:
   \   00000044   0324               MOVS     R4,#+3
   \                     ??startNextConversion_3:
   \   00000046   0A70               STRB     R2,[R1, #+0]
   \   00000048   ........           BL       _writeBasePri
    126            return i;
   \   0000004C   E0B2               UXTB     R0,R4
   \   0000004E   70BD               POP      {R4-R6,PC}       ;; return
    127          }
    128          

   \                                 In section .text, align 2, keep-with-next
    129          void halInternalInitAdc(void)
    130          {
    131            // reset the state variables
    132            adcPendingRequests = 0;
   \                     halInternalInitAdc:
   \   00000000   ....               LDR.N    R0,??DataTable12
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0170               STRB     R1,[R0, #+0]
    133            adcPendingConversion = NUM_ADC_USERS;
   \   00000006   0321               MOVS     R1,#+3
   \   00000008   4170               STRB     R1,[R0, #+1]
    134            adcCalibrated = FALSE;
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   C170               STRB     R1,[R0, #+3]
    135            adcStaticConfig = ADC_1MHZCLK | ADC_ENABLE; // init config: 1MHz, low voltage
   \   0000000E   0521               MOVS     R1,#+5
   \   00000010   0181               STRH     R1,[R0, #+8]
    136          
    137            // set all adcReadings as invalid
    138            adcReadingValid = 0;
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   8170               STRB     R1,[R0, #+2]
    139          
    140            // turn off the ADC
    141            ADC_CFG = 0;                   // disable ADC, turn off HV buffers
   \   00000016   ....               LDR.N    R1,??DataTable12_2  ;; 0x4000d004
   \   00000018   0022               MOVS     R2,#+0
   \   0000001A   0A60               STR      R2,[R1, #+0]
    142            ADC_OFFSET = ADC_OFFSET_RESET;
   \   0000001C   4A60               STR      R2,[R1, #+4]
    143            ADC_GAIN = ADC_GAIN_RESET;
   \   0000001E   4FF40042           MOV      R2,#+32768
   \   00000022   8A60               STR      R2,[R1, #+8]
    144            ADC_DMACFG = ADC_DMARST;
   \   00000024   1022               MOVS     R2,#+16
   \   00000026   CA60               STR      R2,[R1, #+12]
    145            ADC_DMABEG = (int32u)&adcData;
   \   00000028   001D               ADDS     R0,R0,#+4
   \   0000002A   4861               STR      R0,[R1, #+20]
    146            ADC_DMASIZE = 1;
   \   0000002C   0120               MOVS     R0,#+1
   \   0000002E   8861               STR      R0,[R1, #+24]
    147            ADC_DMACFG = (ADC_DMAAUTOWRAP | ADC_DMALOAD);
   \   00000030   0320               MOVS     R0,#+3
   \   00000032   C860               STR      R0,[R1, #+12]
    148          
    149            // clear the ADC interrupts and enable
    150            INT_ADCCFG = INT_ADCULDFULL;
   \   00000034   ....               LDR.N    R0,??DataTable12_1  ;; 0x4000a810
   \   00000036   0421               MOVS     R1,#+4
   \   00000038   0164               STR      R1,[R0, #+64]
    151            INT_ADCFLAG = 0xFFFF;
   \   0000003A   4FF6FF71           MOVW     R1,#+65535
   \   0000003E   0160               STR      R1,[R0, #+0]
    152            INT_CFGSET = INT_ADC;
   \   00000040   ....               LDR.N    R0,??DataTable12_3  ;; 0xe000e100
   \   00000042   4FF40061           MOV      R1,#+2048
   \   00000046   0160               STR      R1,[R0, #+0]
    153          
    154            stCalibrateVref();
   \   00000048   ........           B.W      stCalibrateVref
    155          }
    156          

   \                                 In section .text, align 2, keep-with-next
    157          StStatus halStartAdcConversion(ADCUser id,
    158                                         ADCReferenceType reference,
    159                                         ADCChannelType channel,
    160                                         ADCRateType rate)
    161          {
   \                     halStartAdcConversion:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0446               MOV      R4,R0
    162           
    163             if(reference != ADC_REF_INT)
   \   00000004   C029               CMP      R1,#+192
   \   00000006   01D0               BEQ.N    ??halStartAdcConversion_0
    164              return ST_ERR_FATAL;
   \   00000008   0120               MOVS     R0,#+1
   \   0000000A   70BD               POP      {R4-R6,PC}
    165          
    166            // save the chosen configuration for this user
    167            adcConfig[id] = ( ((rate << ADC_PERIOD_BIT) & ADC_PERIOD)
    168                            | ((channel << ADC_CHAN_BIT) & ADC_CHAN)
    169                            | adcStaticConfig);
   \                     ??halStartAdcConversion_0:
   \   0000000C   ....               LDR.N    R5,??DataTable12
   \   0000000E   D000               LSLS     R0,R2,#+3
   \   00000010   40EA4330           ORR      R0,R0,R3, LSL #+13
   \   00000014   2989               LDRH     R1,[R5, #+8]
   \   00000016   0843               ORRS     R0,R1,R0
   \   00000018   05EB4401           ADD      R1,R5,R4, LSL #+1
   \   0000001C   8882               STRH     R0,[R1, #+20]
   \   0000001E   0120               MOVS     R0,#+1
   \   00000020   00FA04F6           LSL      R6,R0,R4
   \   00000024   2878               LDRB     R0,[R5, #+0]
   \   00000026   3042               TST      R0,R6
   \   00000028   0FD1               BNE.N    ??halStartAdcConversion_1
    170          
    171            // if the user already has a pending request, overwrite params
    172            if (adcPendingRequests & BIT(id)) {
    173              return ST_ADC_CONVERSION_DEFERRED;
    174            }
    175          
    176            ATOMIC (
    177              // otherwise, queue the transaction
    178              adcPendingRequests |= BIT(id);
    179              // try and start the conversion if there is not one happening
    180              adcReadingValid &= ~BIT(id);
    181            )
   \   0000002A   ........           BL       _disableBasePri
   \   0000002E   2978               LDRB     R1,[R5, #+0]
   \   00000030   3143               ORRS     R1,R6,R1
   \   00000032   2970               STRB     R1,[R5, #+0]
   \   00000034   A978               LDRB     R1,[R5, #+2]
   \   00000036   B143               BICS     R1,R1,R6
   \   00000038   A970               STRB     R1,[R5, #+2]
   \   0000003A   ........           BL       _writeBasePri
    182            if (startNextConversion() == id)
   \   0000003E   ........           BL       startNextConversion
   \   00000042   A042               CMP      R0,R4
   \   00000044   01D1               BNE.N    ??halStartAdcConversion_1
    183              return ST_ADC_CONVERSION_BUSY;
   \   00000046   8120               MOVS     R0,#+129
   \   00000048   70BD               POP      {R4-R6,PC}
    184            else
    185              return ST_ADC_CONVERSION_DEFERRED;
   \                     ??halStartAdcConversion_1:
   \   0000004A   8220               MOVS     R0,#+130
   \   0000004C   70BD               POP      {R4-R6,PC}       ;; return
    186          }
    187          

   \                                 In section .text, align 2, keep-with-next
    188          StStatus halRequestAdcData(ADCUser id, int16u *value)
    189          {
   \                     halRequestAdcData:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   0446               MOV      R4,R0
   \   00000006   8846               MOV      R8,R1
    190            //Both the ADC interrupt and the global interrupt need to be enabled,
    191            //otherwise the ADC ISR cannot be serviced.
    192            boolean intsAreOff = ( INTERRUPTS_ARE_OFF()
    193                                  || !(INT_CFGSET & INT_ADC) 
    194                                  || !(INT_ADCCFG & INT_ADCULDFULL) );
   \   00000008   ....               LDR.N    R7,??DataTable12_4  ;; 0x4000a850
   \   0000000A   ....               LDR.N    R5,??DataTable12_3  ;; 0xe000e100
   \   0000000C   ........           BL       _basePriIsDisabled
   \   00000010   50B9               CBNZ.N   R0,??halRequestAdcData_0
   \   00000012   2868               LDR      R0,[R5, #+0]
   \   00000014   0005               LSLS     R0,R0,#+20
   \   00000016   07D5               BPL.N    ??halRequestAdcData_0
   \   00000018   3868               LDR      R0,[R7, #+0]
   \   0000001A   0006               LSLS     R0,R0,#+24
   \   0000001C   800E               LSRS     R0,R0,#+26
   \   0000001E   00F00100           AND      R0,R0,#0x1
   \   00000022   80F00106           EOR      R6,R0,#0x1
   \   00000026   00E0               B.N      ??halRequestAdcData_1
   \                     ??halRequestAdcData_0:
   \   00000028   0126               MOVS     R6,#+1
    195            StStatus stat;
    196          
    197            ATOMIC (
    198              // If interupts are disabled but the flag is set,
    199              // manually run the isr...
    200              //FIXME -= is this valid???
    201              if( intsAreOff 
    202                && ( (INT_CFGSET & INT_ADC) && (INT_ADCCFG & INT_ADCULDFULL) )) {
    203                halAdcIsr();
    204              }
    205           
    206              // check if we are done
    207              if (BIT(id) & adcReadingValid) {
    208                *value = adcReadings[id];
    209                adcReadingValid ^= BIT(id);
    210                stat = ST_ADC_CONVERSION_DONE;
    211              } else if (adcPendingRequests & BIT(id)) {
    212                stat = ST_ADC_CONVERSION_DEFERRED;
    213              } else if (adcPendingConversion == id) {
    214                stat = ST_ADC_CONVERSION_BUSY;
    215              } else {
    216                stat = ST_ADC_NO_CONVERSION_PENDING;
    217              }
    218            )
   \                     ??halRequestAdcData_1:
   \   0000002A   ........           BL       _disableBasePri
   \   0000002E   8146               MOV      R9,R0
   \   00000030   3EB1               CBZ.N    R6,??halRequestAdcData_2
   \   00000032   2868               LDR      R0,[R5, #+0]
   \   00000034   0005               LSLS     R0,R0,#+20
   \   00000036   04D5               BPL.N    ??halRequestAdcData_2
   \   00000038   3868               LDR      R0,[R7, #+0]
   \   0000003A   4007               LSLS     R0,R0,#+29
   \   0000003C   48BF               IT       MI 
   \   0000003E   ........           BLMI     halAdcIsr
   \                     ??halRequestAdcData_2:
   \   00000042   ....               LDR.N    R0,??DataTable12
   \   00000044   8178               LDRB     R1,[R0, #+2]
   \   00000046   0122               MOVS     R2,#+1
   \   00000048   A240               LSLS     R2,R2,R4
   \   0000004A   0A42               TST      R2,R1
   \   0000004C   08D0               BEQ.N    ??halRequestAdcData_3
   \   0000004E   00EB4403           ADD      R3,R0,R4, LSL #+1
   \   00000052   9B89               LDRH     R3,[R3, #+12]
   \   00000054   A8F80030           STRH     R3,[R8, #+0]
   \   00000058   5140               EORS     R1,R2,R1
   \   0000005A   8170               STRB     R1,[R0, #+2]
   \   0000005C   8024               MOVS     R4,#+128
   \   0000005E   09E0               B.N      ??halRequestAdcData_4
   \                     ??halRequestAdcData_3:
   \   00000060   0178               LDRB     R1,[R0, #+0]
   \   00000062   1142               TST      R1,R2
   \   00000064   18BF               IT       NE 
   \   00000066   8224               MOVNE    R4,#+130
   \   00000068   04D1               BNE.N    ??halRequestAdcData_4
   \   0000006A   4078               LDRB     R0,[R0, #+1]
   \   0000006C   A042               CMP      R0,R4
   \   0000006E   0CBF               ITE      EQ 
   \   00000070   8124               MOVEQ    R4,#+129
   \   00000072   8424               MOVNE    R4,#+132
   \                     ??halRequestAdcData_4:
   \   00000074   4846               MOV      R0,R9
   \   00000076   ........           BL       _writeBasePri
    219            return stat;
   \   0000007A   2046               MOV      R0,R4
   \   0000007C   BDE8F283           POP      {R1,R4-R9,PC}    ;; return
    220          }
    221          

   \                                 In section .text, align 2, keep-with-next
    222          StStatus halReadAdcBlocking(ADCUser id, int16u *value)
    223          {
   \                     halReadAdcBlocking:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0446               MOV      R4,R0
   \   00000004   0D46               MOV      R5,R1
    224            StStatus stat;
    225          
    226            do {
    227              stat = halRequestAdcData(id, value);
   \                     ??halReadAdcBlocking_0:
   \   00000006   2946               MOV      R1,R5
   \   00000008   2046               MOV      R0,R4
   \   0000000A   ........           BL       halRequestAdcData
    228              if (stat == ST_ADC_NO_CONVERSION_PENDING)
   \   0000000E   8428               CMP      R0,#+132
   \   00000010   18BF               IT       NE 
   \   00000012   8028               CMPNE    R0,#+128
    229                break;
    230            } while(stat != ST_ADC_CONVERSION_DONE);
   \   00000014   F7D1               BNE.N    ??halReadAdcBlocking_0
    231            return stat;
   \   00000016   32BD               POP      {R1,R4,R5,PC}    ;; return
    232          }
    233          

   \                                 In section .text, align 2, keep-with-next
    234          StStatus halAdcCalibrate(ADCUser id)
    235          {
   \                     halAdcCalibrate:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0446               MOV      R4,R0
    236            StStatus stat;
    237          /* Modified the original ADC driver for enabling the ADC extended range mode required for 
    238               supporting the STLM20 temperature sensor.
    239               NOTE: 
    240               The ADC extended range is inaccurate due to the high voltage mode bug of the general purpose ADC 
    241               (see STM32W108 errata). As consequence, it is not reccomended to use this ADC driver for getting
    242               the temperature values 
    243             */
    244          #ifdef ENABLE_ADC_EXTENDED_RANGE_BROKEN
    245            if(halAdcGetRange()){
    246              
    247              halStartAdcConversion(id,
    248                                    ADC_REF_INT,
    249                                    ADC_SOURCE_VREF_VREF2,
    250                                    ADC_CONVERSION_TIME_US_4096);
    251              
    252              stat = halReadAdcBlocking(id, (int16u *)(&Nvref));
    253              if (stat == ST_ADC_CONVERSION_DONE) {
    254                halStartAdcConversion(id,
    255                                      ADC_REF_INT,
    256                                      ADC_SOURCE_VREF2_VREF2,
    257                                      ADC_CONVERSION_TIME_US_4096);
    258                stat = halReadAdcBlocking(id, (int16u *)(&Nvref2));
    259              }
    260              if (stat == ST_ADC_CONVERSION_DONE) {
    261                adcCalibrated = TRUE;
    262              } else {
    263                adcCalibrated = FALSE;
    264                stat = ST_ERR_FATAL;
    265              }
    266              return stat;    
    267              
    268            }  
    269          #endif /* ENABLE_ADC_EXTENDED_RANGE_BROKEN */
    270            halStartAdcConversion(id,
    271                                  ADC_REF_INT,
    272                                  ADC_SOURCE_GND_VREF2,
    273                                  ADC_CONVERSION_TIME_US_4096);
   \   00000004   0723               MOVS     R3,#+7
   \   00000006   8922               MOVS     R2,#+137
   \   00000008   C021               MOVS     R1,#+192
   \   0000000A   ........           BL       halStartAdcConversion
    274            stat = halReadAdcBlocking(id, (int16u *)(&Nvss));
   \   0000000E   ....               LDR.N    R5,??DataTable12
   \   00000010   05F11C01           ADD      R1,R5,#+28
   \   00000014   2046               MOV      R0,R4
   \   00000016   ........           BL       halReadAdcBlocking
    275            if (stat == ST_ADC_CONVERSION_DONE) {
   \   0000001A   8028               CMP      R0,#+128
   \   0000001C   09D1               BNE.N    ??halAdcCalibrate_0
    276              halStartAdcConversion(id,
    277                                    ADC_REF_INT,
    278                                    ADC_SOURCE_VREG2_VREF2,
    279                                    ADC_CONVERSION_TIME_US_4096);
   \   0000001E   0723               MOVS     R3,#+7
   \   00000020   B922               MOVS     R2,#+185
   \   00000022   C021               MOVS     R1,#+192
   \   00000024   2046               MOV      R0,R4
   \   00000026   ........           BL       halStartAdcConversion
    280              stat = halReadAdcBlocking(id, (int16u *)(&Nvdd));
   \   0000002A   A91D               ADDS     R1,R5,#+6
   \   0000002C   2046               MOV      R0,R4
   \   0000002E   ........           BL       halReadAdcBlocking
    281            }
    282            if (stat == ST_ADC_CONVERSION_DONE) {
   \                     ??halAdcCalibrate_0:
   \   00000032   8028               CMP      R0,#+128
   \   00000034   05D1               BNE.N    ??halAdcCalibrate_1
    283              Nvdd -= Nvss;
   \   00000036   E988               LDRH     R1,[R5, #+6]
   \   00000038   AA8B               LDRH     R2,[R5, #+28]
   \   0000003A   891A               SUBS     R1,R1,R2
   \   0000003C   E980               STRH     R1,[R5, #+6]
    284              adcCalibrated = TRUE;
   \   0000003E   0121               MOVS     R1,#+1
   \   00000040   01E0               B.N      ??halAdcCalibrate_2
    285            } else {
    286              adcCalibrated = FALSE;
   \                     ??halAdcCalibrate_1:
   \   00000042   0021               MOVS     R1,#+0
    287              stat = ST_ERR_FATAL;
   \   00000044   0120               MOVS     R0,#+1
   \                     ??halAdcCalibrate_2:
   \   00000046   E970               STRB     R1,[R5, #+3]
    288            }
    289            return stat;
   \   00000048   32BD               POP      {R1,R4,R5,PC}    ;; return
    290          }
    291          
    292          // Use the ratio of the sample reading to the of VDD_PADSA/2, known to be 900mV,
    293          // to convert to 100uV units.
    294          // FIXME: support external Vref
    295          //        use #define of Vref, ignore VDD_PADSA
    296          // FIXME: support  high voltage range 
    297          //        use Vref-Vref/2 to calibrate
    298          // FIXME: check for mfg token specifying measured VDD_PADSA

   \                                 In section .text, align 2, keep-with-next
    299          int16s halConvertValueToVolts(int16u value)
    300          {
   \                     halConvertValueToVolts:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0446               MOV      R4,R0
    301            int32s N;
    302            int16s V;
    303            int32s nvalue;
    304            
    305            if (!adcCalibrated) {
   \   00000004   ....               LDR.N    R5,??DataTable12
   \   00000006   E878               LDRB     R0,[R5, #+3]
   \   00000008   08B9               CBNZ.N   R0,??halConvertValueToVolts_0
    306              halAdcCalibrate(ADC_USER_LQI);
   \   0000000A   ........           BL       halAdcCalibrate
    307            }
    308            if (adcCalibrated) {
   \                     ??halConvertValueToVolts_0:
   \   0000000E   E878               LDRB     R0,[R5, #+3]
   \   00000010   0028               CMP      R0,#+0
   \   00000012   23D0               BEQ.N    ??halConvertValueToVolts_1
    309           /* Modified the original ADC driver for enabling the ADC extended range mode required for 
    310               supporting the STLM20 temperature sensor.
    311               NOTE: 
    312               The ADC extended range is inaccurate due to the high voltage mode bug of the general purpose ADC 
    313               (see STM32W108 errata). As consequence, it is not reccomended to use this ADC driver for getting
    314               the temperature values 
    315             */
    316          #ifdef ENABLE_ADC_EXTENDED_RANGE_BROKEN
    317              if(halAdcGetRange()){  // High range.
    318                
    319                N = (((int32s)value + Nvref - 2*Nvref2) << 16)/(2*(Nvref-Nvref2));
    320                // Calculate voltage with: V = (N * VREF) / (2^16) where VDD = 1.2 volts
    321                // Mutiplying by 1.2*10000 makes the result of this equation 100 uVolts
    322                V = (int16s)((N*12000L) >> 16);
    323                if (V > 21000) {  // VDD_PADS ?
    324                  V = 21000;
    325                }      
    326                
    327              }
    328              else {
    329           #endif /* ENABLE_ADC_EXTENDED_RANGE_BROKEN */
    330                assert(Nvdd);
   \   00000014   B5F90600           LDRSH    R0,[R5, #+6]
   \   00000018   48B9               CBNZ.N   R0,??halConvertValueToVolts_2
   \   0000001A   4FF4A572           MOV      R2,#+330
   \   0000001E   ........           ADR.W    R1,`?<Constant "I:\\\\\\312\\265\\321\\3514 \\316\\336\\317`
   \   00000022   ........           ADR.W    R0,`?<Constant "Nvdd">`
   \   00000026   ........           BL       __aeabi_assert
   \   0000002A   ........           BL       __iar_EmptyStepPoint
   \                     ??halConvertValueToVolts_2:
   \   0000002E   B5F90600           LDRSH    R0,[R5, #+6]
   \   00000032   B5F91C10           LDRSH    R1,[R5, #+28]
   \   00000036   611A               SUBS     R1,R4,R1
   \   00000038   00EBD072           ADD      R2,R0,R0, LSR #+31
   \   0000003C   5210               ASRS     R2,R2,#+1
   \   0000003E   02EB0141           ADD      R1,R2,R1, LSL #+16
   \   00000042   91FBF0F0           SDIV     R0,R1,R0
   \   00000046   42F22831           MOVW     R1,#+9000
   \   0000004A   4843               MULS     R0,R1,R0
   \   0000004C   0014               ASRS     R0,R0,#+16
    331                nvalue = value - Nvss;
    332                // Convert input value (minus ground) to a fraction of VDD/2.
    333                N = ((nvalue << 16) + Nvdd/2) / Nvdd;
    334                // Calculate voltage with: V = (N * VDD/2) / (2^16) where VDD/2 = 0.9 volts
    335                // Mutiplying by0.9*10000 makes the result of this equation 100 uVolts
    336                // (in fixed point E-4 which allows for 13.5 bits vs millivolts
    337                // which is only 10.2 bits).
    338                V = (int16s)((N*9000L) >> 16);
    339                if (V > 12000) {
   \   0000004E   42F6E161           MOVW     R1,#+12001
   \   00000052   8842               CMP      R0,R1
   \   00000054   03DB               BLT.N    ??halConvertValueToVolts_3
    340                  V = 12000;
   \   00000056   42F6E060           MOVW     R0,#+12000
   \   0000005A   32BD               POP      {R1,R4,R5,PC}
    341                }
    342           #ifdef ENABLE_ADC_EXTENDED_RANGE_BROKEN    
    343              }
    344           #endif /* ENABLE_ADC_EXTENDED_RANGE_BROKEN */   
    345            } else {
    346              V = -32768;
   \                     ??halConvertValueToVolts_1:
   \   0000005C   ....               LDR.N    R0,??DataTable12_5  ;; 0xffff8000
    347            }
    348            return V;
   \                     ??halConvertValueToVolts_3:
   \   0000005E   32BD               POP      {R1,R4,R5,PC}    ;; return
    349          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   ........           DC32     adcPendingRequests

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   10A80040           DC32     0x4000a810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   04D00040           DC32     0x4000d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   00E100E0           DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   50A80040           DC32     0x4000a850

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0080FFFF           DC32     0xffff8000

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Nvdd">`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   4E7664640000       DC8 78, 118, 100, 100, 0, 0, 0, 0
   \              0000        

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "I:\\\\\\312\\265\\321\\3514 \\316\\336\\317`:
   \   00000000                      ; Initializer data, 72 bytes
   \   00000000   493A5CCAB5D1       DC8 73, 58, 92, 202, 181, 209, 233, 52, 32, 206
   \              E93420CE    
   \   0000000A   DECFDFB4ABB8       DC8 222, 207, 223, 180, 171, 184, 208, 198, 247, 189
   \              D0C6F7BD    
   \   00000014   DAB5E3B6E0B5       DC8 218, 181, 227, 182, 224, 181, 227, 205, 168, 208
   \              E3CDA8D0    
   \   0000001E   C5CAB5D1E95C       DC8 197, 202, 181, 209, 233, 92, 185, 164, 179, 204
   \              B9A4B3CC    
   \   00000028   D4B4B4FAC2EB       DC8 212, 180, 180, 250, 194, 235, 92, 104, 97, 108
   \              5C68616C    
   \   00000032   5C6D6963726F       DC8 92, 109, 105, 99, 114, 111, 92, 99, 111, 114
   \              5C636F72    
   \   0000003C   7465786D335C       DC8 116, 101, 120, 109, 51, 92, 97, 100, 99, 46
   \              6164632E    
   \   00000046   6300               DC8 99, 0

   Maximum stack usage in bytes:

     Function               .cstack
     --------               -------
     halAdcCalibrate            16
     halAdcGetClock              0
     halAdcGetRange              0
     halAdcIsr                  16
     halAdcSetClock              0
     halAdcSetRange              0
     halConvertValueToVolts     16
     halInternalInitAdc          8
     halReadAdcBlocking         16
     halRequestAdcData          32
     halStartAdcConversion      16
     startNextConversion        16


   Section sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     adcPendingRequests                               30
     adcPendingConversion
     adcReadingValid
     adcCalibrated
     adcData
     Nvdd
     adcStaticConfig
     adcReadings
     adcConfig
     Nvss
     halAdcSetClock                                   22
     halAdcSetRange                                   22
     halAdcGetClock                                   14
     halAdcGetRange                                   16
     halAdcIsr                                       100
     startNextConversion                              80
     halInternalInitAdc                               76
     halStartAdcConversion                            78
     halRequestAdcData                               128
     halReadAdcBlocking                               24
     halAdcCalibrate                                  74
     halConvertValueToVolts                           96
     ??DataTable12                                     4
     ??DataTable12_1                                   4
     ??DataTable12_2                                   4
     ??DataTable12_3                                   4
     ??DataTable12_4                                   4
     ??DataTable12_5                                   4
     ?<Constant "Nvdd">                                8
     ?<Constant "I:\\\312\265\321\3514 \316\336\317   72

 
  30 bytes in section .bss
 834 bytes in section .text
 
 834 bytes of CODE memory
  30 bytes of DATA memory

Errors: none
Warnings: none
