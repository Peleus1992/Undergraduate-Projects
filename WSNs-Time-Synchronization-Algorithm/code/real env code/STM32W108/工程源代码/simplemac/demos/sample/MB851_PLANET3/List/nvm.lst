###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     05/Jul/2014  18:38:04 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  I:\实验4 无线传感器节点多点通信实验\工程源代码\hal\micro #
#                    \cortexm3\nvm.c                                          #
#    Command line =  "I:\实验4 无线传感器节点多点通信实验\工程源代码\hal\micr #
#                    o\cortexm3\nvm.c" -D BOARD_MB851 -D                      #
#                    "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\""  #
#                    -D "BOARD_HEADER=\"hal/micro/cortexm3/stm32w108/board.h\ #
#                    "" -D CORTEXM3 -D CORTEXM3_STM32W108 -D PHY_STM32W108XX  #
#                    -D DISABLE_WATCHDOG -D PLANET_ROLE -D BOARD_MB851 -D     #
#                    "__SOURCEFILE__=\"nvm.c\"" -lC "I:\实验4                 #
#                    无线传感器节点多点通信实验\工程源代码\simplemac\demos\sa #
#                    mple\MB851_PLANET3\List\" --diag_suppress Pa050 -o       #
#                    "I:\实验4 无线传感器节点多点通信实验\工程源代码\simplema #
#                    c\demos\sample\MB851_PLANET3\Obj\" --debug               #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "D:\study soft\IAR6.10\IARsoft\arm\INC\c\D #
#                    Lib_Config_Normal.h" -I "I:\实验4                        #
#                    无线传感器节点多点通信实验\工程源代码\hal\micro\cortexm3 #
#                    \" -I "I:\实验4 无线传感器节点多点通信实验\工程源代码\si #
#                    mplemac\demos\sample\..\..\..\simplemac\include\" -I     #
#                    "I:\实验4 无线传感器节点多点通信实验\工程源代码\simplema #
#                    c\demos\sample\..\..\..\" -I "I:\实验4                   #
#                    无线传感器节点多点通信实验\工程源代码\simplemac\demos\sa #
#                    mple\..\..\..\hal\" -I "I:\实验4                         #
#                    无线传感器节点多点通信实验\工程源代码\simplemac\demos\sa #
#                    mple\..\..\..\HAL\MICRO\CORTEXM3\STM32W108\" -I          #
#                    "I:\实验4 无线传感器节点多点通信实验\工程源代码\simplema #
#                    c\demos\sample\..\..\..\simplemac\" -I "I:\实验4         #
#                    无线传感器节点多点通信实验\工程源代码\simplemac\demos\sa #
#                    mple\..\..\..\shared\" -Ohz --use_c++_inline             #
#    List file    =  I:\实验4 无线传感器节点多点通信实验\工程源代码\simplemac #
#                    \demos\sample\MB851_PLANET3\List\nvm.lst                 #
#    Object file  =  I:\实验4 无线传感器节点多点通信实验\工程源代码\simplemac #
#                    \demos\sample\MB851_PLANET3\Obj\nvm.o                    #
#                                                                             #
#                                                                             #
###############################################################################

I:\实验4 无线传感器节点多点通信实验\工程源代码\hal\micro\cortexm3\nvm.c
      1          /** @file hal/micro/cortexm3/nvm.c
      2           * @brief Cortex-M3 Non-Volatile Memory data storage system.
      3           *
      4           * This file implements the NVM data storage system.  Refer to nvm.h for
      5           * full documentation of how the NVM data storage system works, is configured,
      6           * and is accessed.
      7           *
      8           * <!--(C) COPYRIGHT 2010 STMicroelectronics. All rights reserved.        -->
      9           */
     10          
     11          #include PLATFORM_HEADER
     12          #include "error.h"
     13          //flash.h gives access to halInternalFlashErase and halInternalFlashWrite.
     14          #include "hal/micro/cortexm3/flash.h"
     15          //nvm.h includes memmap.h.  These two headers define the key parameters:
     16          //  MFB_PAGE_SIZE_B
     17          //  MFB_TOP
     18          //  NVM_LEFT_PAGE
     19          //  NVM_RIGHT_PAGE
     20          //  NVM_DATA_SIZE_B
     21          //  NVM_FLASH_PAGE_COUNT
     22          //  NVM_MGMT_SIZE_B
     23          #include "hal/micro/cortexm3/nvm.h"
     24          
     25          //Define two variables that hold the actual NVM data storage.  LEFT and RIGHT
     26          //are not required to be continuous memory blocks so they can be define
     27          //separately.  The linker is responsible for placing these storage containers
     28          //on flash page boundaries.

   \                                 In section NVM, align 4, root
     29          NO_STRIPPING __no_init VAR_AT_SEGMENT (const int8u nvmStorageLeft[NVM_DATA_SIZE_B], __NVM__);
   \                     nvmStorageLeft:
   \   00000000                      DS8 1024

   \                                 In section NVM, align 4, root
     30          NO_STRIPPING __no_init VAR_AT_SEGMENT (const int8u nvmStorageRight[NVM_DATA_SIZE_B], __NVM__);
   \                     nvmStorageRight:
   \   00000000                      DS8 1024
     31          

   \                                 In section .text, align 2, keep-with-next
     32          static int8u determineState(void)
     33          {
     34            int32u leftMgmt = *(int32u *)NVM_LEFT_PAGE;
   \                     determineState:
   \   00000000   ........           LDR.W    R0,??DataTable9
   \   00000004   0068               LDR      R0,[R0, #+0]
     35            int32u rightMgmt = *(int32u *)NVM_RIGHT_PAGE;
   \   00000006   ........           LDR.W    R1,??DataTable9_1
   \   0000000A   0968               LDR      R1,[R1, #+0]
     36            int8u state=0;
     37            
     38            if((leftMgmt==0xFFFF0000) && (rightMgmt==0xFFFFFFFF)) {
   \   0000000C   6FF0FF02           MVN      R2,#+255
   \   00000010   ........           LDR.W    R3,??DataTable9_2  ;; 0xffff0000
   \   00000014   9842               CMP      R0,R3
   \   00000016   13D1               BNE.N    ??determineState_0
   \   00000018   11F1010F           CMN      R1,#+1
   \   0000001C   01D1               BNE.N    ??determineState_1
     39              //State 1 and state 4 use identical mgmt words.  The function
     40              //determineState() is only called at the start of a NVM read
     41              //or write.  During a read, state 1 and 4 both read from the
     42              //LEFT so there is no reason to make a distinction.  During
     43              //a write, the system will see the current page as LEFT and
     44              //therefore be transitioning from LEFT to RIGHT so state 4 is
     45              //correct.  State 1 is only required to transition from 0 to 2.
     46              state = 4;
   \   0000001E   0420               MOVS     R0,#+4
   \   00000020   7047               BX       LR
     47            } else if((leftMgmt==0xFFFF0000) && (rightMgmt==0xFF00FFFF)) {
   \                     ??determineState_1:
   \   00000022   6FF47F00           MVN      R0,#+16711680
   \   00000026   8142               CMP      R1,R0
   \   00000028   01D1               BNE.N    ??determineState_2
     48              state = 2;
   \   0000002A   0220               MOVS     R0,#+2
   \   0000002C   7047               BX       LR
     49            } else if((leftMgmt==0xFFFF0000) && (rightMgmt==0xFF000000)) {
   \                     ??determineState_2:
   \   0000002E   11F1807F           CMN      R1,#+16777216
   \   00000032   01D1               BNE.N    ??determineState_3
     50              state = 3;
   \   00000034   0320               MOVS     R0,#+3
   \   00000036   7047               BX       LR
     51            } else if((leftMgmt==0xFFFF0000) && (rightMgmt==0xFFFFFFFF)) {
   \                     ??determineState_3:
   \   00000038   9142               CMP      R1,R2
   \   0000003A   1ED1               BNE.N    ??determineState_4
     52              state = 4;
     53            } else if((leftMgmt==0xFFFF0000) && (rightMgmt==0xFFFFFF00)) {
     54              state = 5;
   \   0000003C   0520               MOVS     R0,#+5
   \   0000003E   7047               BX       LR
     55            } else if((leftMgmt==0xFF000000) && (rightMgmt==0xFFFFFF00)) {
   \                     ??determineState_0:
   \   00000040   10F1807F           CMN      R0,#+16777216
   \   00000044   03D1               BNE.N    ??determineState_5
   \   00000046   9142               CMP      R1,R2
   \   00000048   08D1               BNE.N    ??determineState_6
     56              state = 6;
   \   0000004A   0620               MOVS     R0,#+6
   \   0000004C   7047               BX       LR
     57            } else if((leftMgmt==0xFF000000) && (rightMgmt==0xFFFF0000)) {
     58              state = 7;
     59            } else if((leftMgmt==0xFFFFFFFF) && (rightMgmt==0xFFFF0000)) {
   \                     ??determineState_5:
   \   0000004E   10F1010F           CMN      R0,#+1
   \   00000052   07D1               BNE.N    ??determineState_7
   \   00000054   9942               CMP      R1,R3
   \   00000056   10D1               BNE.N    ??determineState_4
     60              state = 8;
   \   00000058   0820               MOVS     R0,#+8
   \   0000005A   7047               BX       LR
     61            } else if((leftMgmt==0xFFFFFF00) && (rightMgmt==0xFFFF0000)) {
   \                     ??determineState_6:
   \   0000005C   9942               CMP      R1,R3
   \   0000005E   0CD1               BNE.N    ??determineState_4
   \   00000060   0720               MOVS     R0,#+7
   \   00000062   7047               BX       LR
   \                     ??determineState_7:
   \   00000064   9042               CMP      R0,R2
   \   00000066   08D1               BNE.N    ??determineState_4
   \   00000068   9942               CMP      R1,R3
   \   0000006A   01D1               BNE.N    ??determineState_8
     62              state = 9;
   \   0000006C   0920               MOVS     R0,#+9
   \   0000006E   7047               BX       LR
     63            } else if((leftMgmt==0xFFFFFF00) && (rightMgmt==0xFF000000)) {
   \                     ??determineState_8:
   \   00000070   11F1807F           CMN      R1,#+16777216
   \   00000074   01D1               BNE.N    ??determineState_4
     64              state = 10;
   \   00000076   0A20               MOVS     R0,#+10
   \   00000078   7047               BX       LR
     65            } else {
     66              //State 0 is used to indicate erased or invalid.
     67              state = 0;
   \                     ??determineState_4:
   \   0000007A   0020               MOVS     R0,#+0
     68            }
     69            
     70            return state;
   \   0000007C   7047               BX       LR               ;; return
     71          }
     72          
     73          

   \                                 In section .text, align 2, keep-with-next
     74          int8u halCommonReadFromNvm(void *data, int32u offset, int16u length)
     75          {
   \                     halCommonReadFromNvm:
   \   00000000   2DE9F047           PUSH     {R4-R10,LR}
   \   00000004   8146               MOV      R9,R0
   \   00000006   0D46               MOV      R5,R1
   \   00000008   1746               MOV      R7,R2
     76            int16u i;
     77            int16u *flash;
     78            //Remember: all flash writes are 16bits.
     79            int16u *ram = (int16u*)data;
     80            
     81            //The NVM data storage system cannot function if the LEFT and RIGHT
     82            //storage are not aligned to physical flash pages.
     83            assert((NVM_LEFT_PAGE%MFB_PAGE_SIZE_B)==0);
   \   0000000A   ........           ADR.W    R8,`?<Constant "I:\\\\\\312\\265\\321\\3514 \\316\\336\\317`
   \   0000000E   40F2FF3A           MOVW     R10,#+1023
   \   00000012   ........           LDR.W    R6,??DataTable9
   \   00000016   16EA0A0F           TST      R6,R10
   \   0000001A   05D0               BEQ.N    ??halCommonReadFromNvm_0
   \   0000001C   5322               MOVS     R2,#+83
   \   0000001E   4146               MOV      R1,R8
   \   00000020   ........           BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_11:
   \   00000024   ........           BL       __iar_EmptyStepPoint
     84            assert((NVM_RIGHT_PAGE%MFB_PAGE_SIZE_B)==0);
   \                     ??halCommonReadFromNvm_0:
   \   00000028   ........           LDR.W    R4,??DataTable9_1
   \   0000002C   14EA0A0F           TST      R4,R10
   \   00000030   05D0               BEQ.N    ??halCommonReadFromNvm_1
   \   00000032   5422               MOVS     R2,#+84
   \   00000034   4146               MOV      R1,R8
   \   00000036   ........           BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_14:
   \   0000003A   ........           BL       __iar_EmptyStepPoint
     85            //The offset of the NVM data must be 16bit aligned.
     86            assert((offset&0x1)==0);
   \                     ??halCommonReadFromNvm_1:
   \   0000003E   E807               LSLS     R0,R5,#+31
   \   00000040   05D5               BPL.N    ??halCommonReadFromNvm_2
   \   00000042   5622               MOVS     R2,#+86
   \   00000044   4146               MOV      R1,R8
   \   00000046   ........           BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_17:
   \   0000004A   ........           BL       __iar_EmptyStepPoint
     87            //The length of the NVM data must be 16bit aligned.
     88            assert((length&0x1)==0);
   \                     ??halCommonReadFromNvm_2:
   \   0000004E   F807               LSLS     R0,R7,#+31
   \   00000050   07D5               BPL.N    ??halCommonReadFromNvm_3
   \   00000052   5822               MOVS     R2,#+88
   \   00000054   4146               MOV      R1,R8
   \   00000056   ........           ADR.W    R0,`?<Constant "(length&0x1)==0">`
   \   0000005A   ........           BL       __aeabi_assert
   \   0000005E   ........           BL       __iar_EmptyStepPoint
     89            
     90            assert(offset+length<NVM_DATA_SIZE_B);
   \                     ??halCommonReadFromNvm_3:
   \   00000062   7819               ADDS     R0,R7,R5
   \   00000064   B0F5806F           CMP      R0,#+1024
   \   00000068   07D3               BCC.N    ??halCommonReadFromNvm_4
   \   0000006A   5A22               MOVS     R2,#+90
   \   0000006C   4146               MOV      R1,R8
   \   0000006E   ........           ADR.W    R0,`?<Constant "offset+length<NVM_DAT...">`
   \   00000072   ........           BL       __aeabi_assert
   \   00000076   ........           BL       __iar_EmptyStepPoint
     91            
     92            //Obtain the data from NVM storage.
     93            switch(determineState()) {
   \                     ??halCommonReadFromNvm_4:
   \   0000007A   ........           BL       determineState
   \   0000007E   401E               SUBS     R0,R0,#+1
   \   00000080   0328               CMP      R0,#+3
   \   00000082   05D9               BLS.N    ??halCommonReadFromNvm_5
   \   00000084   001F               SUBS     R0,R0,#+4
   \   00000086   0328               CMP      R0,#+3
   \   00000088   0ED9               BLS.N    ??halCommonReadFromNvm_6
   \   0000008A   001F               SUBS     R0,R0,#+4
   \   0000008C   0128               CMP      R0,#+1
   \   0000008E   17D8               BHI.N    ??halCommonReadFromNvm_7
     94              case 1:
     95              case 2:
     96              case 3:
     97              case 4:
     98              case 9:
     99              case 10:
    100                flash = (int16u *)(NVM_LEFT_PAGE+offset);
   \                     ??halCommonReadFromNvm_5:
   \   00000090   A819               ADDS     R0,R5,R6
    101                for(i=0;i<(length/2);i++) {
   \   00000092   0021               MOVS     R1,#+0
   \                     ??halCommonReadFromNvm_8:
   \   00000094   B1EB570F           CMP      R1,R7, LSR #+1
   \   00000098   BEBF               ITTT     LT 
   \   0000009A   30F81120           LDRHLT   R2,[R0, R1, LSL #+1]
   \   0000009E   29F81120           STRHLT   R2,[R9, R1, LSL #+1]
   \   000000A2   491C               ADDLT    R1,R1,#+1
    102                  ram[i] = flash[i];
   \   000000A4   F6DB               BLT.N    ??halCommonReadFromNvm_8
   \   000000A6   17E0               B.N      ??halCommonReadFromNvm_9
    103                }
    104              break;
    105              case 5:
    106              case 6:
    107              case 7:
    108              case 8:
    109                flash = (int16u *)(NVM_RIGHT_PAGE+offset);
   \                     ??halCommonReadFromNvm_6:
   \   000000A8   2819               ADDS     R0,R5,R4
    110                for(i=0;i<(length/2);i++) {
   \   000000AA   0021               MOVS     R1,#+0
   \                     ??halCommonReadFromNvm_10:
   \   000000AC   B1EB570F           CMP      R1,R7, LSR #+1
   \   000000B0   BEBF               ITTT     LT 
   \   000000B2   30F81120           LDRHLT   R2,[R0, R1, LSL #+1]
   \   000000B6   29F81120           STRHLT   R2,[R9, R1, LSL #+1]
   \   000000BA   491C               ADDLT    R1,R1,#+1
    111                  ram[i] = flash[i];
   \   000000BC   F6DB               BLT.N    ??halCommonReadFromNvm_10
   \   000000BE   0BE0               B.N      ??halCommonReadFromNvm_9
    112                }
    113              break;
    114              case 0:
    115              default:
    116                //Reading from NVM while the mgmt bytes are in an invalid state
    117                //should not return any bytes actually found in flash.  Instead,
    118                //return nothing but 0xFF.  This is legitimate because the next
    119                //call to the write function will also find invalid mgmt bytes
    120                //and trigger an erasure of NVM, after which the NVM really will
    121                //contain just 0xFF for data (plus the new data supplied during
    122                //the write call).
    123                for(i=0;i<(length/2);i++) {
   \                     ??halCommonReadFromNvm_7:
   \   000000C0   0021               MOVS     R1,#+0
   \   000000C2   4FF6FF70           MOVW     R0,#+65535
   \   000000C6   02E0               B.N      ??halCommonReadFromNvm_11
    124                  ram[i] = 0xFFFF;
   \                     ??halCommonReadFromNvm_12:
   \   000000C8   29F81100           STRH     R0,[R9, R1, LSL #+1]
    125                }
   \   000000CC   491C               ADDS     R1,R1,#+1
   \                     ??halCommonReadFromNvm_11:
   \   000000CE   B1EB570F           CMP      R1,R7, LSR #+1
   \   000000D2   F9DB               BLT.N    ??halCommonReadFromNvm_12
    126              //Inform the calling code. using ST_ERR_FATAL, that there were
    127              //invalid mgmt bytes and 0xFF was forcefully returned.
    128              return ST_ERR_FATAL;
   \   000000D4   0120               MOVS     R0,#+1
   \   000000D6   00E0               B.N      ??halCommonReadFromNvm_13
    129            }
    130            
    131            return ST_SUCCESS;
   \                     ??halCommonReadFromNvm_9:
   \   000000D8   0020               MOVS     R0,#+0
   \                     ??halCommonReadFromNvm_13:
   \   000000DA   BDE8F087           POP      {R4-R10,PC}      ;; return
    132          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   2946               MOV      R1,R5
   \                     ??Subroutine6_0:
   \   00000002   ........           ADR.W    R0,`?<Constant "(offset&0x1)==0">`
   \   00000006   ........           B.W      __aeabi_assert

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   2946               MOV      R1,R5
   \                     ??Subroutine5_0:
   \   00000002   ........           ADR.W    R0,`?<Constant "(NVM_RIGHT_PAGE%MFB_P...">`
   \   00000006   ........           B.W      __aeabi_assert

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   2946               MOV      R1,R5
   \                     ??Subroutine4_0:
   \   00000002   ........           ADR.W    R0,`?<Constant "(NVM_LEFT_PAGE%MFB_PA...">`
   \   00000006   ........           B.W      __aeabi_assert
    133          

   \                                 In section .text, align 2, keep-with-next
    134          int16u *halCommonGetAddressFromNvm(int32u offset)
    135          {
   \                     halCommonGetAddressFromNvm:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   82B0               SUB      SP,SP,#+8
   \   00000006   0446               MOV      R4,R0
    136            int16u *flash;
    137            
    138            //The NVM data storage system cannot function if the LEFT and RIGHT
    139            //storage are not aligned to physical flash pages.
    140            assert((NVM_LEFT_PAGE%MFB_PAGE_SIZE_B)==0);
   \   00000008   ........           ADR.W    R5,`?<Constant "I:\\\\\\312\\265\\321\\3514 \\316\\336\\317`
   \   0000000C   40F2FF38           MOVW     R8,#+1023
   \   00000010   ....               LDR.N    R6,??DataTable9
   \   00000012   16EA080F           TST      R6,R8
   \   00000016   04D0               BEQ.N    ??halCommonGetAddressFromNvm_0
   \   00000018   8C22               MOVS     R2,#+140
   \   0000001A   ........           BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_13:
   \   0000001E   ........           BL       __iar_EmptyStepPoint
    141            assert((NVM_RIGHT_PAGE%MFB_PAGE_SIZE_B)==0);
   \                     ??halCommonGetAddressFromNvm_0:
   \   00000022   ....               LDR.N    R7,??DataTable9_1
   \   00000024   17EA080F           TST      R7,R8
   \   00000028   04D0               BEQ.N    ??halCommonGetAddressFromNvm_1
   \   0000002A   8D22               MOVS     R2,#+141
   \   0000002C   ........           BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_16:
   \   00000030   ........           BL       __iar_EmptyStepPoint
    142            //The offset of the NVM data must be 16bit aligned.
    143            assert((offset&0x1)==0);
   \                     ??halCommonGetAddressFromNvm_1:
   \   00000034   E007               LSLS     R0,R4,#+31
   \   00000036   04D5               BPL.N    ??halCommonGetAddressFromNvm_2
   \   00000038   8F22               MOVS     R2,#+143
   \   0000003A   ........           BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_19:
   \   0000003E   ........           BL       __iar_EmptyStepPoint
    144            
    145            //Obtain the data from NVM storage.
    146            switch(determineState()) {
   \                     ??halCommonGetAddressFromNvm_2:
   \   00000042   A519               ADDS     R5,R4,R6
   \   00000044   ........           BL       determineState
   \   00000048   401E               SUBS     R0,R0,#+1
   \   0000004A   0328               CMP      R0,#+3
   \   0000004C   11D9               BLS.N    ??halCommonGetAddressFromNvm_3
   \   0000004E   001F               SUBS     R0,R0,#+4
   \   00000050   0328               CMP      R0,#+3
   \   00000052   03D9               BLS.N    ??halCommonGetAddressFromNvm_4
   \   00000054   001F               SUBS     R0,R0,#+4
   \   00000056   0128               CMP      R0,#+1
   \   00000058   0BD9               BLS.N    ??halCommonGetAddressFromNvm_3
   \   0000005A   01E0               B.N      ??halCommonGetAddressFromNvm_5
    147              case 1:
    148              case 2:
    149              case 3:
    150              case 4:
    151              case 9:
    152              case 10:
    153                flash = (int16u *)(NVM_LEFT_PAGE+offset);
    154              break;
    155              case 5:
    156              case 6:
    157              case 7:
    158              case 8:
    159                flash = (int16u *)(NVM_RIGHT_PAGE+offset);
   \                     ??halCommonGetAddressFromNvm_4:
   \   0000005C   E519               ADDS     R5,R4,R7
    160              break;
   \   0000005E   08E0               B.N      ??halCommonGetAddressFromNvm_3
    161              case 0:
    162              default:
    163                // Flash is in an invalid state 
    164                // Fix it with a dummy write and then return the flash page left
    165                {
    166          	int16u dummy = 0xFFFF;
   \                     ??halCommonGetAddressFromNvm_5:
   \   00000060   4FF6FF70           MOVW     R0,#+65535
   \   00000064   ADF80000           STRH     R0,[SP, #+0]
    167          	halCommonWriteToNvm(&dummy, 0, 2);
   \   00000068   0222               MOVS     R2,#+2
   \   0000006A   0021               MOVS     R1,#+0
   \   0000006C   00A8               ADD      R0,SP,#+0
   \   0000006E   ........           BL       halCommonWriteToNvm
    168          	flash = (int16u *)(NVM_LEFT_PAGE+offset);
    169                }
    170            }
    171            
    172            return flash;
   \                     ??halCommonGetAddressFromNvm_3:
   \   00000072   2846               MOV      R0,R5
   \   00000074   BDE8F681           POP      {R1,R2,R4-R8,PC}  ;; return
    173          }
    174          
    175          

   \                                 In section .text, align 2, keep-with-next
    176          static int8u erasePage(int32u page)
    177          {
   \                     erasePage:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0446               MOV      R4,R0
    178            StStatus status;
    179            int32u i, k;
    180            int32u address;
    181            int8u *flash;
    182            
    183            //Erasing a LEFT or RIGHT page requires erasing all of the flash pages.
    184            //Since the mgmt bytes are stored at the bottom of a page, the flash pages
    185            //are erased from the top down ensuring that that mgmt words are the last
    186            //data to be erased.  This way, if a reset occurs while erasing, the mgmt
    187            //words are still valid the next time determineState() is called.
    188            for(i=NVM_FLASH_PAGE_COUNT;i>0;i--) {
   \   00000004   0125               MOVS     R5,#+1
    189              address = (page+((i-1)*MFB_PAGE_SIZE_B));
   \                     ??erasePage_0:
   \   00000006   6D1E               SUBS     R5,R5,#+1
   \   00000008   04EB8526           ADD      R6,R4,R5, LSL #+10
    190              flash = (int8u *)address;
   \   0000000C   3746               MOV      R7,R6
    191              //Scan the page to determine if it is fully erased already.
    192              //If the flash is not erased, erase it.  The purpose of scanning
    193              //first is to save a little time if erasing is not required.
    194              for(k=0;k<MFB_PAGE_SIZE_B;k++,flash++) {
   \   0000000E   0020               MOVS     R0,#+0
    195                if(*flash != 0xFF) {
   \                     ??erasePage_1:
   \   00000010   3978               LDRB     R1,[R7, #+0]
   \   00000012   FF29               CMP      R1,#+255
   \   00000014   06D0               BEQ.N    ??erasePage_2
    196                  status = halInternalFlashErase(MFB_PAGE_ERASE, address);
   \   00000016   3146               MOV      R1,R6
   \   00000018   0220               MOVS     R0,#+2
   \   0000001A   ........           BL       halInternalFlashErase
    197                  if(status != ST_SUCCESS) {
   \   0000001E   48B9               CBNZ.N   R0,??erasePage_3
    198                    return status;
    199                  }
    200                  //Don't bother looking at the rest of this flash page and just
    201                  //move to the next.
    202                  k=MFB_PAGE_SIZE_B;
   \   00000020   4FF48060           MOV      R0,#+1024
    203                }
    204              }
   \                     ??erasePage_2:
   \   00000024   401C               ADDS     R0,R0,#+1
   \   00000026   7F1C               ADDS     R7,R7,#+1
   \   00000028   B0F5806F           CMP      R0,#+1024
   \   0000002C   F0D3               BCC.N    ??erasePage_1
    205            }
   \   0000002E   002D               CMP      R5,#+0
   \   00000030   E9D1               BNE.N    ??erasePage_0
    206            return ST_SUCCESS;
   \   00000032   0020               MOVS     R0,#+0
   \                     ??erasePage_3:
   \   00000034   F2BD               POP      {R1,R4-R7,PC}    ;; return
    207          }
    208          
    209          
    210          //This macro is responsible for erasing an NVM page (LEFT or RIGHT).
    211          #define ERASE_PAGE(page)          \
    212            do {                            \
    213              status = erasePage(page);     \
    214              if(status != ST_SUCCESS) { \
    215                return status;              \
    216              }                             \
    217            } while(0)
    218          
    219          
    220          //This macro is responsible for writing the new data into the destination
    221          //page and copying existing data from the source page to the
    222          //destination page.
    223          #define WRITE_DATA(destPage, srcPage, offset, length)                     \
    224            do {                                                                    \
    225              /*Copy all data below the new data from the srcPage to the destPage*/ \
    226              status = halInternalFlashWrite(destPage+NVM_MGMT_SIZE_B,              \
    227                                             (int16u *)(srcPage+NVM_MGMT_SIZE_B),   \
    228                                             (offset-NVM_MGMT_SIZE_B)/2);           \
    229              if(status != ST_SUCCESS) { return status; }                        \
    230              /*Write the new data*/                                                \
    231              status = halInternalFlashWrite(destPage+offset,                       \
    232                                             ram,                                   \
    233                                             (length)/2);                           \
    234              if(status != ST_SUCCESS) { return status; }                        \
    235              /*Copy all data above the new data from the srcPage to the destPage*/ \
    236              status = halInternalFlashWrite(destPage+offset+length,                \
    237                                             (int16u *)(srcPage+offset+length),     \
    238                                             (NVM_DATA_SIZE_B-                      \
    239                                              length-offset-                        \
    240                                              NVM_MGMT_SIZE_B)/2);                  \
    241              if(status != ST_SUCCESS) { return status; }                        \
    242            } while(0)
    243          
    244          //This macro is responsible for writing 16bits of management data to
    245          //the proper management address.
    246          #define WRITE_MGMT_16BITS(address, data)                  \
    247            do{                                                     \
    248              int16u value = data;                                  \
    249              status = halInternalFlashWrite((address), &value, 1); \
    250              if(status != ST_SUCCESS) {                         \
    251                return status;                                      \
    252              }                                                     \
    253            } while(0)
    254          
    255          

   \                                 In section .text, align 4, keep-with-next
    256          int8u halCommonWriteToNvm(const void *data, int32u offset, int16u length)
    257          {
   \                     halCommonWriteToNvm:
   \   00000000   2DE9F54F           PUSH     {R0,R2,R4-R11,LR}
   \   00000004   83B0               SUB      SP,SP,#+12
   \   00000006   0E46               MOV      R6,R1
    258            StStatus status;
    259            int8u state, exitState;
    260            int32u srcPage;
    261            int32u destPage;
    262            //Remember: NVM data storage works on 16bit quantities.
    263            int16u *ram = (int16u*)data;
    264            
    265            //The NVM data storage system cannot function if the LEFT and RIGHT
    266            //storage are not aligned to physical flash pages.
    267            assert((NVM_LEFT_PAGE%MFB_PAGE_SIZE_B)==0);
   \   00000008   ........           ADR.W    R5,`?<Constant "I:\\\\\\312\\265\\321\\3514 \\316\\336\\317`
   \   0000000C   40F2FF34           MOVW     R4,#+1023
   \   00000010   ........           LDR.W    R8,??DataTable9
   \   00000014   18EA040F           TST      R8,R4
   \   00000018   05D0               BEQ.N    ??halCommonWriteToNvm_1
   \   0000001A   40F20B12           MOVW     R2,#+267
   \   0000001E   ........           BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_12:
   \   00000022   ........           BL       __iar_EmptyStepPoint
    268            assert((NVM_RIGHT_PAGE%MFB_PAGE_SIZE_B)==0);
   \                     ??halCommonWriteToNvm_1:
   \   00000026   ........           LDR.W    R10,??DataTable9_1
   \   0000002A   1AEA040F           TST      R10,R4
   \   0000002E   05D0               BEQ.N    ??halCommonWriteToNvm_2
   \   00000030   4FF48672           MOV      R2,#+268
   \   00000034   ........           BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_15:
   \   00000038   ........           BL       __iar_EmptyStepPoint
    269            //The offset of the NVM data must be 16bit aligned.
    270            assert((offset&0x1)==0);
   \                     ??halCommonWriteToNvm_2:
   \   0000003C   F007               LSLS     R0,R6,#+31
   \   0000003E   05D5               BPL.N    ??halCommonWriteToNvm_3
   \   00000040   4FF48772           MOV      R2,#+270
   \   00000044   ........           BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_18:
   \   00000048   ........           BL       __iar_EmptyStepPoint
    271            //The length of the NVM data must be 16bit aligned.
    272            assert((length&0x1)==0);
   \                     ??halCommonWriteToNvm_3:
   \   0000004C   BDF81000           LDRH     R0,[SP, #+16]
   \   00000050   C007               LSLS     R0,R0,#+31
   \   00000052   08D5               BPL.N    ??halCommonWriteToNvm_4
   \   00000054   4FF48872           MOV      R2,#+272
   \   00000058   2946               MOV      R1,R5
   \   0000005A   ........           ADR.W    R0,`?<Constant "(length&0x1)==0">`
   \   0000005E   ........           BL       __aeabi_assert
   \   00000062   ........           BL       __iar_EmptyStepPoint
    273            //It is illegal to write to an offset outside of NVM storage.
    274            assert(offset+length<NVM_DATA_SIZE_B);
   \                     ??halCommonWriteToNvm_4:
   \   00000066   BDF81040           LDRH     R4,[SP, #+16]
   \   0000006A   A019               ADDS     R0,R4,R6
   \   0000006C   B0F5806F           CMP      R0,#+1024
   \   00000070   08D3               BCC.N    ??halCommonWriteToNvm_5
   \   00000072   4FF48972           MOV      R2,#+274
   \   00000076   2946               MOV      R1,R5
   \   00000078   ........           ADR.W    R0,`?<Constant "offset+length<NVM_DAT...">`
   \   0000007C   ........           BL       __aeabi_assert
   \   00000080   ........           BL       __iar_EmptyStepPoint
    275            
    276            
    277            state = determineState();
   \                     ??halCommonWriteToNvm_5:
   \   00000084   ........           BL       determineState
    278            
    279            switch(state) {
   \   00000088   BDF81010           LDRH     R1,[SP, #+16]
   \   0000008C   C1F58061           RSB      R1,R1,#+1024
   \   00000090   891B               SUBS     R1,R1,R6
   \   00000092   091F               SUBS     R1,R1,#+4
   \   00000094   4FEA510B           LSR      R11,R1,#+1
   \   00000098   3419               ADDS     R4,R6,R4
   \   0000009A   311F               SUBS     R1,R6,#+4
   \   0000009C   4908               LSRS     R1,R1,#+1
   \   0000009E   0191               STR      R1,[SP, #+4]
   \   000000A0   411E               SUBS     R1,R0,#+1
   \   000000A2   0329               CMP      R1,#+3
   \   000000A4   05D9               BLS.N    ??halCommonWriteToNvm_6
   \   000000A6   091F               SUBS     R1,R1,#+4
   \   000000A8   0329               CMP      R1,#+3
   \   000000AA   18D9               BLS.N    ??halCommonWriteToNvm_7
   \   000000AC   091F               SUBS     R1,R1,#+4
   \   000000AE   0129               CMP      R1,#+1
   \   000000B0   1AD8               BHI.N    ??halCommonWriteToNvm_8
    280              case 1:
    281              case 2:
    282              case 3:
    283              case 4:
    284              case 9:
    285              case 10:
    286                srcPage = NVM_LEFT_PAGE;
   \                     ??halCommonWriteToNvm_6:
   \   000000B2   4746               MOV      R7,R8
    287                destPage = NVM_RIGHT_PAGE;
   \   000000B4   5546               MOV      R5,R10
    288                exitState = 7;
   \   000000B6   4FF00709           MOV      R9,#+7
    289              break;
    290              case 5:
    291              case 6:
    292              case 7:
    293              case 8:
    294                srcPage = NVM_RIGHT_PAGE;
    295                destPage = NVM_LEFT_PAGE;
    296                exitState = 3;
    297              break;
    298              case 0:
    299              default:
    300                //Invalid state.  Default to writing to the LEFT page.  Defaulting to
    301                //using RIGHT as the source page is valid since the RIGHT page
    302                //will also be erased and therefore produce 0xFF for data values.
    303                state = 0;
    304                srcPage = NVM_RIGHT_PAGE;
    305                destPage = NVM_LEFT_PAGE;
    306                exitState = 3;
    307              break;
    308            }
    309            
    310            //Advance the state machine.  Starting on state 3 requires state 7 to
    311            //exit and starting on state 7 requires state 3 to exit.  Starting on
    312            //any other state requires either 3 or 7 to exit.
    313            //NOTE:  Refer to nvm.h for a description of the states and how the
    314            //       state transitions correspond to erasing, writing data, and
    315            //       writing mgmt values.
    316            while(TRUE) {
    317              switch(state) {
   \                     ??halCommonWriteToNvm_9:
   \   000000BA   0A28               CMP      R0,#+10
   \   000000BC   FDD8               BHI.N    ??halCommonWriteToNvm_9
   \   000000BE   DFE800F0           TBB      [PC, R0]
   \                     ??halCommonWriteToNvm_0:
   \   000000C2   072D3135           DC8      0x7,0x2D,0x31,0x35
   \   000000C6   3F515D61           DC8      0x3F,0x51,0x5D,0x61
   \   000000CA   697B7F00           DC8      0x69,0x7B,0x7F,0x0
   \                     ??halCommonWriteToNvm_10:
   \   000000CE   F4E7               B.N      ??halCommonWriteToNvm_9
    318                case 0:
    319                  //State 0 is the only state where the source page needs to be erased.
    320                  ERASE_PAGE(srcPage);
   \                     ??halCommonWriteToNvm_11:
   \   000000D0   3846               MOV      R0,R7
   \   000000D2   ........           BL       erasePage
   \   000000D6   60B1               CBZ.N    R0,??halCommonWriteToNvm_12
   \                     ??halCommonWriteToNvm_13:
   \   000000D8   05B0               ADD      SP,SP,#+20
   \   000000DA   BDE8F08F           POP      {R4-R11,PC}      ;; return
   \                     ??halCommonWriteToNvm_7:
   \   000000DE   5746               MOV      R7,R10
   \   000000E0   4546               MOV      R5,R8
   \   000000E2   4FF00309           MOV      R9,#+3
   \   000000E6   E8E7               B.N      ??halCommonWriteToNvm_9
   \                     ??halCommonWriteToNvm_8:
   \   000000E8   5746               MOV      R7,R10
   \   000000EA   4546               MOV      R5,R8
   \   000000EC   4FF00309           MOV      R9,#+3
   \   000000F0   EEE7               B.N      ??halCommonWriteToNvm_11
    321                  ERASE_PAGE(destPage);
   \                     ??halCommonWriteToNvm_12:
   \   000000F2   2846               MOV      R0,R5
   \   000000F4   ........           BL       erasePage
   \   000000F8   0028               CMP      R0,#+0
   \   000000FA   EDD1               BNE.N    ??halCommonWriteToNvm_13
    322                  WRITE_DATA(destPage, srcPage, offset, length);
   \   000000FC   ........           BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_22:
   \   00000100   0028               CMP      R0,#+0
   \   00000102   E9D1               BNE.N    ??halCommonWriteToNvm_13
   \   00000104   ........           BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_8:
   \   00000108   0028               CMP      R0,#+0
   \   0000010A   E5D1               BNE.N    ??halCommonWriteToNvm_13
   \   0000010C   ........           BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_25:
   \   00000110   0028               CMP      R0,#+0
   \   00000112   E1D1               BNE.N    ??halCommonWriteToNvm_13
    323                  WRITE_MGMT_16BITS(NVM_LEFT_PAGE+0, 0x0000);
   \   00000114   ........           BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2:
   \   00000118   0028               CMP      R0,#+0
   \   0000011A   DDD1               BNE.N    ??halCommonWriteToNvm_13
    324                  state=1;
    325                break;
    326                case 1:
    327                  WRITE_MGMT_16BITS(NVM_RIGHT_PAGE+2, 0xFF00);
   \                     ??halCommonWriteToNvm_14:
   \   0000011C   ........           BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_10:
   \   00000120   0028               CMP      R0,#+0
   \   00000122   D9D1               BNE.N    ??halCommonWriteToNvm_13
    328                  state=2;
    329                break;
    330                case 2:
    331                  WRITE_MGMT_16BITS(NVM_RIGHT_PAGE+0, 0x0000);
   \                     ??halCommonWriteToNvm_15:
   \   00000124   ........           BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_5:
   \   00000128   0028               CMP      R0,#+0
   \   0000012A   D5D1               BNE.N    ??halCommonWriteToNvm_13
    332                  state=3;
    333                break;
    334                case 3:
    335                  if(exitState==3) {
   \                     ??halCommonWriteToNvm_16:
   \   0000012C   B9F1030F           CMP      R9,#+3
   \   00000130   01D1               BNE.N    ??halCommonWriteToNvm_17
    336                    return ST_SUCCESS;
   \                     ??halCommonWriteToNvm_18:
   \   00000132   0020               MOVS     R0,#+0
   \   00000134   D0E7               B.N      ??halCommonWriteToNvm_13
    337                  }
    338                  ERASE_PAGE(destPage);
   \                     ??halCommonWriteToNvm_17:
   \   00000136   2846               MOV      R0,R5
   \   00000138   ........           BL       erasePage
   \   0000013C   0028               CMP      R0,#+0
   \   0000013E   CBD1               BNE.N    ??halCommonWriteToNvm_13
    339                  state=4;
    340                break;
    341                case 4:
    342                  WRITE_DATA(destPage, srcPage, offset, length);
   \                     ??halCommonWriteToNvm_19:
   \   00000140   ........           BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_21:
   \   00000144   0028               CMP      R0,#+0
   \   00000146   C7D1               BNE.N    ??halCommonWriteToNvm_13
   \   00000148   ........           BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_7:
   \   0000014C   0028               CMP      R0,#+0
   \   0000014E   C3D1               BNE.N    ??halCommonWriteToNvm_13
   \   00000150   ........           BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_24:
   \   00000154   0028               CMP      R0,#+0
   \   00000156   BFD1               BNE.N    ??halCommonWriteToNvm_13
    343                  WRITE_MGMT_16BITS(NVM_RIGHT_PAGE+0, 0xFF00);
   \   00000158   4FF47F40           MOV      R0,#+65280
   \   0000015C   ........           BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_3:
   \   00000160   0028               CMP      R0,#+0
   \   00000162   B9D1               BNE.N    ??halCommonWriteToNvm_13
    344                  state=5;
    345                break;
    346                case 5:
    347                  WRITE_MGMT_16BITS(NVM_LEFT_PAGE+2, 0xFF00);
   \                     ??halCommonWriteToNvm_20:
   \   00000164   4FF47F40           MOV      R0,#+65280
   \   00000168   ADF80000           STRH     R0,[SP, #+0]
   \   0000016C   0122               MOVS     R2,#+1
   \   0000016E   00A9               ADD      R1,SP,#+0
   \   00000170   08F10200           ADD      R0,R8,#+2
   \   00000174   ........           BL       halInternalFlashWrite
   \   00000178   0028               CMP      R0,#+0
   \   0000017A   ADD1               BNE.N    ??halCommonWriteToNvm_13
    348                  state=6;
    349                break;
    350                case 6:
    351                  WRITE_MGMT_16BITS(NVM_RIGHT_PAGE+0, 0x0000);
   \                     ??halCommonWriteToNvm_21:
   \   0000017C   ........           BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4:
   \   00000180   0028               CMP      R0,#+0
   \   00000182   A9D1               BNE.N    ??halCommonWriteToNvm_13
    352                  state=7;
    353                break;
    354                case 7:
    355                  if(exitState==7) {
   \                     ??halCommonWriteToNvm_22:
   \   00000184   B9F1070F           CMP      R9,#+7
   \   00000188   D3D0               BEQ.N    ??halCommonWriteToNvm_18
    356                    return ST_SUCCESS;
    357                  }
    358                  ERASE_PAGE(destPage);
   \   0000018A   2846               MOV      R0,R5
   \   0000018C   ........           BL       erasePage
   \   00000190   0028               CMP      R0,#+0
   \   00000192   A1D1               BNE.N    ??halCommonWriteToNvm_13
    359                  state=8;
    360                break;
    361                case 8:
    362                  WRITE_DATA(destPage, srcPage, offset, length);
   \                     ??halCommonWriteToNvm_23:
   \   00000194   ........           BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_20:
   \   00000198   0028               CMP      R0,#+0
   \   0000019A   9DD1               BNE.N    ??halCommonWriteToNvm_13
   \   0000019C   ........           BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_6:
   \   000001A0   0028               CMP      R0,#+0
   \   000001A2   99D1               BNE.N    ??halCommonWriteToNvm_13
   \   000001A4   ........           BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_23:
   \   000001A8   0028               CMP      R0,#+0
   \   000001AA   95D1               BNE.N    ??halCommonWriteToNvm_13
    363                  WRITE_MGMT_16BITS(NVM_LEFT_PAGE+0, 0xFF00);
   \   000001AC   4FF47F40           MOV      R0,#+65280
   \   000001B0   ........           BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1:
   \   000001B4   0028               CMP      R0,#+0
   \   000001B6   8FD1               BNE.N    ??halCommonWriteToNvm_13
    364                  state=9;
    365                break;
    366                case 9:
    367                  WRITE_MGMT_16BITS(NVM_RIGHT_PAGE+2, 0xFF00);
   \                     ??halCommonWriteToNvm_24:
   \   000001B8   ........           BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_9:
   \   000001BC   0028               CMP      R0,#+0
   \   000001BE   8BD1               BNE.N    ??halCommonWriteToNvm_13
    368                  state=10;
    369                break;
    370                case 10:
    371                  WRITE_MGMT_16BITS(NVM_LEFT_PAGE+0, 0x0000);
   \                     ??halCommonWriteToNvm_25:
   \   000001C0   0020               MOVS     R0,#+0
   \   000001C2   ........           BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0:
   \   000001C6   0028               CMP      R0,#+0
   \   000001C8   86D1               BNE.N    ??halCommonWriteToNvm_13
   \   000001CA   AFE7               B.N      ??halCommonWriteToNvm_16
    372                  state=3;
    373                break;
    374              }
    375            }
    376          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8:
   \   00000000   5A46               MOV      R2,R11
   \   00000002   3919               ADDS     R1,R7,R4
   \   00000004   2819               ADDS     R0,R5,R4
   \   00000006   ........           B.W      halInternalFlashWrite

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7:
   \   00000000   019A               LDR      R2,[SP, #+4]
   \   00000002   391D               ADDS     R1,R7,#+4
   \   00000004   281D               ADDS     R0,R5,#+4
   \   00000006   ........           B.W      halInternalFlashWrite

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   4FF47F40           MOV      R0,#+65280
   \   00000004   ADF80000           STRH     R0,[SP, #+0]
   \   00000008   0122               MOVS     R2,#+1
   \   0000000A   00A9               ADD      R1,SP,#+0
   \   0000000C   0AF10200           ADD      R0,R10,#+2
   \   00000010   ........           B.W      halInternalFlashWrite

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   BDF81000           LDRH     R0,[SP, #+16]
   \   00000004   4208               LSRS     R2,R0,#+1
   \   00000006   0399               LDR      R1,[SP, #+12]
   \   00000008   7019               ADDS     R0,R6,R5
   \   0000000A   ........           B.W      halInternalFlashWrite

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0020               MOVS     R0,#+0
   \                     ??Subroutine1_0:
   \   00000002   ADF80000           STRH     R0,[SP, #+0]
   \   00000006   0122               MOVS     R2,#+1
   \   00000008   00A9               ADD      R1,SP,#+0
   \   0000000A   5046               MOV      R0,R10
   \   0000000C   ........           B.W      halInternalFlashWrite

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   ADF80000           STRH     R0,[SP, #+0]
   \   00000004   0122               MOVS     R2,#+1
   \   00000006   00A9               ADD      R1,SP,#+0
   \   00000008   4046               MOV      R0,R8
   \   0000000A   ........           B.W      halInternalFlashWrite

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     nvmStorageLeft

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   ........           DC32     nvmStorageRight

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0000FFFF           DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "(NVM_LEFT_PAGE%MFB_PA...">`:
   \   00000000                      ; Initializer data, 36 bytes
   \   00000000   284E564D5F4C       DC8 40, 78, 86, 77, 95, 76, 69, 70, 84, 95
   \              4546545F    
   \   0000000A   50414745254D       DC8 80, 65, 71, 69, 37, 77, 70, 66, 95, 80
   \              46425F50    
   \   00000014   4147455F5349       DC8 65, 71, 69, 95, 83, 73, 90, 69, 95, 66
   \              5A455F42    
   \   0000001E   293D3D300000       DC8 41, 61, 61, 48, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "I:\\\\\\312\\265\\321\\3514 \\316\\336\\317`:
   \   00000000                      ; Initializer data, 72 bytes
   \   00000000   493A5CCAB5D1       DC8 73, 58, 92, 202, 181, 209, 233, 52, 32, 206
   \              E93420CE    
   \   0000000A   DECFDFB4ABB8       DC8 222, 207, 223, 180, 171, 184, 208, 198, 247, 189
   \              D0C6F7BD    
   \   00000014   DAB5E3B6E0B5       DC8 218, 181, 227, 182, 224, 181, 227, 205, 168, 208
   \              E3CDA8D0    
   \   0000001E   C5CAB5D1E95C       DC8 197, 202, 181, 209, 233, 92, 185, 164, 179, 204
   \              B9A4B3CC    
   \   00000028   D4B4B4FAC2EB       DC8 212, 180, 180, 250, 194, 235, 92, 104, 97, 108
   \              5C68616C    
   \   00000032   5C6D6963726F       DC8 92, 109, 105, 99, 114, 111, 92, 99, 111, 114
   \              5C636F72    
   \   0000003C   7465786D335C       DC8 116, 101, 120, 109, 51, 92, 110, 118, 109, 46
   \              6E766D2E    
   \   00000046   6300               DC8 99, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "(NVM_RIGHT_PAGE%MFB_P...">`:
   \   00000000                      ; Initializer data, 36 bytes
   \   00000000   284E564D5F52       DC8 40, 78, 86, 77, 95, 82, 73, 71, 72, 84
   \              49474854    
   \   0000000A   5F5041474525       DC8 95, 80, 65, 71, 69, 37, 77, 70, 66, 95
   \              4D46425F    
   \   00000014   504147455F53       DC8 80, 65, 71, 69, 95, 83, 73, 90, 69, 95
   \              495A455F    
   \   0000001E   42293D3D3000       DC8 66, 41, 61, 61, 48, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "(offset&0x1)==0">`:
   \   00000000                      ; Initializer data, 16 bytes
   \   00000000   286F66667365       DC8 40, 111, 102, 102, 115, 101, 116, 38, 48, 120
   \              74263078    
   \   0000000A   31293D3D3000       DC8 49, 41, 61, 61, 48, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "(length&0x1)==0">`:
   \   00000000                      ; Initializer data, 16 bytes
   \   00000000   286C656E6774       DC8 40, 108, 101, 110, 103, 116, 104, 38, 48, 120
   \              68263078    
   \   0000000A   31293D3D3000       DC8 49, 41, 61, 61, 48, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "offset+length<NVM_DAT...">`:
   \   00000000                      ; Initializer data, 32 bytes
   \   00000000   6F6666736574       DC8 111, 102, 102, 115, 101, 116, 43, 108, 101, 110
   \              2B6C656E    
   \   0000000A   6774683C4E56       DC8 103, 116, 104, 60, 78, 86, 77, 95, 68, 65
   \              4D5F4441    
   \   00000014   54415F53495A       DC8 84, 65, 95, 83, 73, 90, 69, 95, 66, 0
   \              455F4200    
   \   0000001E   0000               DC8 0, 0
    377          

   Maximum stack usage in bytes:

     Function                   .cstack
     --------                   -------
     determineState                  0
     erasePage                      24
     halCommonGetAddressFromNvm     32
     halCommonReadFromNvm           32
     halCommonWriteToNvm            56


   Section sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     nvmStorageLeft                                 1024
     nvmStorageRight                                1024
     determineState                                  126
     halCommonReadFromNvm                            222
     ?Subroutine6                                     10
     ?Subroutine5                                     10
     ?Subroutine4                                     10
     halCommonGetAddressFromNvm                      120
     erasePage                                        54
     halCommonWriteToNvm                             460
     ?Subroutine8                                     10
     ?Subroutine7                                     10
     ?Subroutine3                                     20
     ?Subroutine2                                     14
     ?Subroutine1                                     16
     ?Subroutine0                                     14
     ??DataTable9                                      4
     ??DataTable9_1                                    4
     ??DataTable9_2                                    4
     ?<Constant "(NVM_LEFT_PAGE%MFB_PA...">           36
     ?<Constant "I:\\\312\265\321\3514 \316\336\317   72
     ?<Constant "(NVM_RIGHT_PAGE%MFB_P...">           36
     ?<Constant "(offset&0x1)==0">                    16
     ?<Constant "(length&0x1)==0">                    16
     ?<Constant "offset+length<NVM_DAT...">           32

 
 1 316 bytes in section .text
 2 048 bytes in section NVM
 
 1 316 bytes of CODE memory
 2 048 bytes of DATA memory

Errors: none
Warnings: none
