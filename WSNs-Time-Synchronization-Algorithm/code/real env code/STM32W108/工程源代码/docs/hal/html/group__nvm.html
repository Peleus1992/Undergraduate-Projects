<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">

<title>Hardware Abstraction Layer: Nvm</title>

<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">

</head><body>

<table border="0" cellspacing="0" cellpadding="0"  width=100%>

<tr>

<td><img src="ST_Logo.gif"></td>

<td> <div class="qindex">

<a class="qindex" href="index.html">Home</a>&nbsp;

 | &nbsp;<a class="qindex" href="modules.html">Modules</a>&nbsp;

 | &nbsp;<a class="qindex" href="annotated.html">Data Structures</a>&nbsp;

 | &nbsp;<a class="qindex" href="files.html">File List</a>&nbsp;

 | &nbsp;<a class="qindex" href="globals.html">Index</a></div>

</td>

</table>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Nvm</h1>
<p>Data definitions for the Cortex-M3 Non-Volatile Memory data storage system.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#gabbb742680b66285439ef9a1df5986610">NVM_RADIO_CAL_OFFSET</a>&nbsp;&nbsp;&nbsp;(NVM_MGMT_SIZE_B+0x0000)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#gacab82da1aef071ca8ec37015ee313c4a">NVM_RADIO_CAL_SIZE_B</a>&nbsp;&nbsp;&nbsp;64</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#ga6b9903ba1464e0fe86e356d2af171e8e">NVM_FOO_OFFSET</a>&nbsp;&nbsp;&nbsp;(NVM_MGMT_SIZE_B+0x0040)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#ga1497f4e9d097e285d60b6acea412f625">NVM_FOO_SIZE_B</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#gad1aa99b6344ca133d629ce28ef198d67">NVM_HAM_OFFSET</a>&nbsp;&nbsp;&nbsp;(NVM_MGMT_SIZE_B+0x0042)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#ga6c50f1148acced416b73aa2422f41457">NVM_HAM_SIZE_B</a>&nbsp;&nbsp;&nbsp;10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#ga68420abf429766d7c669d762127df736">NVM_SPAM_OFFSET</a>&nbsp;&nbsp;&nbsp;(NVM_MGMT_SIZE_B+0x004C)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#gac750f6d9cc3e1841159a63a76fc76278">NVM_SPAM_SIZE_B</a>&nbsp;&nbsp;&nbsp;20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#gac69b416959214ba71992405f12df6194">NVM_FLASH_PAGE_COUNT</a>&nbsp;&nbsp;&nbsp;(1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define the number of physical flash pages that comprise a NVM page. Since NVM_DATA_SIZE_B must be a multiple of MFB_PAGE_SIZE_B, increasing the size of NVM storage should be done by modifying this define.  <a href="#gac69b416959214ba71992405f12df6194"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#gaf82c3a8a7dccec38e893a2cf87cfcd72">NVM_DATA_SIZE_B</a>&nbsp;&nbsp;&nbsp;(MFB_PAGE_SIZE_B*NVM_FLASH_PAGE_COUNT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define the total size of a NVM page, in bytes. This must be a multiple of the memory map define MFB_PAGE_SIZE_B. Note that 4 bytes of the total size of an NVM page are dedicated to page management.  <a href="#gaf82c3a8a7dccec38e893a2cf87cfcd72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#ga2ce94dda9f5641155bbb4eae60a7ede6">NVM_LEFT_PAGE</a>&nbsp;&nbsp;&nbsp;((<a class="el" href="group__iar.html#ga2ba8e0357fdc7b7a450e6893ed81e8e3">int32u</a>)nvmStorageLeft)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define the absolute address of the LEFT page. LEFT page storage is defined by nvmStorageLeft[NVM_DATA_SIZE_B] and placed by the linker using the segment "NVM".  <a href="#ga2ce94dda9f5641155bbb4eae60a7ede6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#gac6d032a9b1418fc2378f7dd35df05738">NVM_RIGHT_PAGE</a>&nbsp;&nbsp;&nbsp;((<a class="el" href="group__iar.html#ga2ba8e0357fdc7b7a450e6893ed81e8e3">int32u</a>)nvmStorageRight)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define the absolute address of the RIGHT page. RIGHT page storage is defined by nvmStorageRight[NVM_DATA_SIZE_B] and placed by the linker using the segment "NVM".  <a href="#gac6d032a9b1418fc2378f7dd35df05738"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#gac8953aab91c6b245cd9c0f03fe88d4bf">NVM_MGMT_SIZE_B</a>&nbsp;&nbsp;&nbsp;(4)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define the number of bytes that comprise the NVM management bytes. All data must begin at an offset above the management bytes.  <a href="#gac8953aab91c6b245cd9c0f03fe88d4bf"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__micro.html#gafddf1f4a9c9eff790d56c8950c1fb0ad">StStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#ga94b214413e5f6af2473a8dafc63bf350">halCommonReadFromNvm</a> (void *data, <a class="el" href="group__iar.html#ga2ba8e0357fdc7b7a450e6893ed81e8e3">int32u</a> offset, <a class="el" href="group__iar.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a> length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the NVM data from flash into the provided RAM location. It is illegal for the offset to be greater than NVM_DATA_SIZE_B.  <a href="#ga94b214413e5f6af2473a8dafc63bf350"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__iar.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#ga75ec83fdb3880797604bbc124fc6738c">halCommonGetAddressFromNvm</a> (<a class="el" href="group__iar.html#ga2ba8e0357fdc7b7a450e6893ed81e8e3">int32u</a> offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the address of the token in NVM.  <a href="#ga75ec83fdb3880797604bbc124fc6738c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__micro.html#gafddf1f4a9c9eff790d56c8950c1fb0ad">StStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm.html#ga2efce64dd793cbbcb56c362b5489a379">halCommonWriteToNvm</a> (const void *data, <a class="el" href="group__iar.html#ga2ba8e0357fdc7b7a450e6893ed81e8e3">int32u</a> offset, <a class="el" href="group__iar.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a> length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the NVM data from the provided location RAM into flash. It is illegal for the offset to be greater than NVM_DATA_SIZE_B.  <a href="#ga2efce64dd793cbbcb56c362b5489a379"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Data definitions for the Cortex-M3 Non-Volatile Memory data storage system. </p>
<p>Cortex-M3 Non-Volatile Memory data storage system.</p>
<p>This header defines all of the data sets in the NVM data storage. Each piece of data in NVM storage uses an offset to indicate where the data lives and a size to indicate the size of that data. Both the offset and size are defined in bytes and must be a mupltiple of 16bits. The offset is from the start of an NVM page, defined by NVM_LEFT_PAGE and NVM_RIGHT_PAGE. The offset and size must be below the maximum size of NVM storage as defined by NVM_DATA_SIZE_B. All NVM data must start above NVM_MGMT_SIZE_B, since this is where the management bytes live.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This file is not directly used by the <a class="el" href="nvm_8c.html" title="Cortex-M3 Non-Volatile Memory data storage system.">nvm.c</a> or <a class="el" href="nvm_8h.html" title="Cortex-M3 Non-Volatile Memory data storage system. See Nvm for documentation.">nvm.h</a> files. This file is intended to be a convenient place to define all data that lives in NVM so it can be seen together in one group. <a class="el" href="nvm_8h.html" title="Cortex-M3 Non-Volatile Memory data storage system. See Nvm for documentation.">nvm.h</a> includes this file which means any code that includes <a class="el" href="nvm_8h.html" title="Cortex-M3 Non-Volatile Memory data storage system. See Nvm for documentation.">nvm.h</a> to call the read and write functions also has access to these defines.</dd></dl>
<p>This header defines the API for NVM data storage. This header also describes the algorithm behind the NVM data storage system with notes on algorithm behavior.</p>
<p>See <a class="el" href="nvm_8h.html" title="Cortex-M3 Non-Volatile Memory data storage system. See Nvm for documentation.">hal/micro/cortexm3/nvm.h</a> for source code.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The algorithm description uses "page" to indicate an area of memory that is a multiple of physical flash pages. There are two pages: LEFT and RIGHT. The term "flash page" is used to refer to a page of physical flash.</dd></dl>
<p>NVM data storage works by alternating between two pages: LEFT and RIGHT. The basic algorithm is driven by a call to halCommonSaveToNvm(). It will:</p>
<ul>
<li>erase the inactive page</li>
<li>write the new data to the inactive page</li>
<li>copy existing data from the active page to the inactive page</li>
<li>mark the inactive page as the new active page</li>
<li>mark the old active page as the new inactive page To accomplish alternating between two pages and knowing which page has the valid set of data, the algorithm uses 4 bytes of mgmt data that exists at the top of both LEFT and RIGHT (the term "mgmt" is shorthand referring to the management data). The management data is comprised of a Valid marker, an Active marker, a Dead marker, and a Spare byte. Viewing the management data as a single 32 bit quantity yields:</li>
<li>Valid is mgmt[0]</li>
<li>Active is mgmt[1]</li>
<li>Dead is mgmt[2]</li>
<li>Spare is mgmt[3] The algorithm is based on a simple, circular state machine. The following discussion details all of the possible mgmt bytes and the states they correspond to. The "Reads from" line indicates which page a call to <a class="el" href="group__nvm.html#ga94b214413e5f6af2473a8dafc63bf350" title="Copy the NVM data from flash into the provided RAM location. It is illegal for the...">halCommonReadFromNvm()</a> will read from (an 'x' page will stuff the read data with 0xFF). The vertical "erase" and "write" words indicate the flash altering actions taken between those states. Invalid mgmt bytes is equivalent to erased mgmt bytes (state 0) and will trigger an erase of both LEFT and RIGHT. State 3 and state 7 are the only exit states. When the algorithm is run, regardless of starting state, it will advance to the next exit state. This means if the "Read from" is LEFT then the state machine will advance until state 7 and then exit. If "Read from" is RIGHT, then the state machine will advance until state 3 and then exit.</li>
</ul>
<div class="fragment"><pre class="fragment"> Starting from erased or invalid mgmt, write to LEFT
 State #       0     0         1      2      3  
 Reads from:   x     x   e w   L      L      L  
 Valid       xx|xx FF|FF r r 00|FF  00|FF  00|00
 Active      xx|xx FF|FF a i 00|FF  00|FF  00|00
 Dead        xx|xx FF|FF s t FF|FF  FF|00  FF|00
 Spare       xx|xx FF|FF e e FF|FF  FF|FF  FF|FF
 
 
 Starting from LEFT page, transition to RIGHT page:
 State #      3       4       5      6      7  
 Reads from:  L   e   L   w   R      R      R  
 Valid      00|00 r 00|FF r 00|00  00|00  00|00
 Active     00|00 a 00|FF i 00|FF  00|FF  00|00
 Dead       FF|00 s FF|FF t FF|FF  00|FF  00|FF
 Spare      FF|FF e FF|FF e FF|FF  FF|FF  FF|FF
 
 
 Starting from RIGHT page, transition to LEFT page:
 State #      7       8       9     10      3  
 Reads from:  R   e   R   w   L      L      L  
 Valid      00|00 r FF|00 r 00|00  00|00  00|00
 Active     00|00 a FF|00 i FF|00  FF|00  00|00
 Dead       00|FF s FF|FF t FF|FF  FF|00  FF|00
 Spare      FF|FF e FF|FF e FF|FF  FF|FF  FF|FF
</pre></div><p>Based on the 10 possible states, there are 5 valid 32bit mgmt words:</p>
<ul>
<li>0xFFFFFFFF</li>
<li>0xFFFFFF00</li>
<li>0xFFFF0000</li>
<li>0xFF000000</li>
<li>0xFF00FFFF The algorithm determines the current state by using these 5 mgmt words with the 10 possible combinations of LEFT mgmt and RIGHT mgmt.</li>
</ul>
<p>Detailed State Description:</p>
<ul>
<li>State 0: In this state the mgmt bytes do not conform to any of the other states and therefore the entire NVM system, both the LEFT and RIGHT, is invalid. Invalid could be as simple as both LEFT and RIGHT are erased or as complex as serious memory corruption or a bug caused bad data to be written to the NVM. By using a small set of very strict, precise, valid states (versus other management systems such as a simple counter), the algorithm/data gains some protection against not only corruption, but also executing the NVM algorithm on a chip that previously did not have the NVM system running on it.</li>
<li>State 1, 4, 8 In these states, mgmt is saying that one page is valid and active, while the other page is erased. This tells the algorithm which page to read from and indicates that the other page has already been erased.</li>
<li>State 2 This state is only necessary for transitioning from state 0. From state 0, the goal is to arrive at state 3. Ideally, the RIGHT mgmt would be written with 0xFF000000, but the flash library only permits 16 bit writes. If a reset were to occur in the middle of this section of the algorithm, we want to ensure that the mgmt is left in a known state, state 2, so that the algorithm could continue from where it got interrupted.</li>
<li>State 5, 9 These states indicate that the other page has just become valid because the new data has just been written. Once at these states, reading from the NVM will now pull data from the other page.</li>
<li>State 6, 10 These states indicate that the old page is now dead and not in use. While the algorithm already knows to read from the new page, the Dead mgmt byte is primarily used to indicate that the other page needs to be erased. Conceptually, the Dead byte can also be considered a type of "garbage collection" flag indicating the old page needs to be destroyed and has not yet been erased.</li>
<li>State 3, 7 These states are the final exit points of the circular state machine. Once at these states, the current page is marked Valid and Active and the old page is marked as Dead. The algorithm knows which page to read from and which page needs to be erased on the next write to the NVM.</li>
</ul>
<p>Notes on algorithm behavior:</p>
<ul>
<li>Refer to <a class="el" href="nvm-def_8h.html" title="Data definitions for the Cortex-M3 Non-Volatile Memory data storage system. See Nvm...">nvm-def.h</a> for a list of offset/length that define the data stored in NVM storage space.</li>
<li>All writes to flash are 16bit granularity and therefore the internal flash writes cast the data to int16u. Length is also required to be a multiple of 16bits.</li>
<li>Flash page erase uses a granularity of a single flash page. The size of a flash page depends on the chip and is defined in memmap.h with the define MFB_PAGE_SIZE_B.</li>
<li>Erasing will only occur when halCommonSaveToNvm() is called.</li>
<li>Erasing will always occur when halCommonSaveToNvm() is called unless the page intended to be erased is already entirely 0xFFFF.</li>
<li>When reading and management is invalid, the read will return 0xFF for data.</li>
<li>Calling halCommonSaveToNvm() while in any state is always valid and the new data will be written to flash.</li>
<li>halCommonSaveToNvm() will always advance the state machine to 3 or 7.</li>
<li>When writing and management is invalid, both LEFT and RIGHT will be erased and the new data will be written to LEFT.</li>
<li>Writing causes the new data being passed into halCommonSaveToNvm() to be written to flash. The data already existing in the currently valid page will be copied over to the new page.</li>
<li>Reading or writing to an offset equal to or greater than NVM_DATA_SIZE_B is illegal and will cause an assert.</li>
<li>Offset and length must always be multiples of 16bits. If not, both a read and a write will trigger an assert.</li>
<li>Offset and length must be supplied in bytes.</li>
<li>All data in NVM storage must exist above the mgmt bytes, denoted by NVM_MGMT_SIZE_B.</li>
<li>The bottom 64 bytes of NVM storage are allocated to radio calibration values. These 64 bytes *must* exist for the radio to function.</li>
<li>There is no error checking beyond checking for 16bit alignment. This means it is possible to use data offset and size combinations that exceed NVM storage space or overlap with other data. Be careful! </li>
</ul>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gaf82c3a8a7dccec38e893a2cf87cfcd72"></a><!-- doxytag: member="nvm.h::NVM_DATA_SIZE_B" ref="gaf82c3a8a7dccec38e893a2cf87cfcd72" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_DATA_SIZE_B&nbsp;&nbsp;&nbsp;(MFB_PAGE_SIZE_B*NVM_FLASH_PAGE_COUNT)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the total size of a NVM page, in bytes. This must be a multiple of the memory map define MFB_PAGE_SIZE_B. Note that 4 bytes of the total size of an NVM page are dedicated to page management. </p>
<dl class="note"><dt><b>Note:</b></dt><dd><b>DO NOT EDIT THIS DEFINE. Instead, edit NVM_FLASH_PAGE_COUNT.</b> </dd></dl>

<p>Definition at line <a class="el" href="nvm_8h_source.html#l00249">249</a> of file <a class="el" href="nvm_8h_source.html">nvm.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac69b416959214ba71992405f12df6194"></a><!-- doxytag: member="nvm.h::NVM_FLASH_PAGE_COUNT" ref="gac69b416959214ba71992405f12df6194" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_FLASH_PAGE_COUNT&nbsp;&nbsp;&nbsp;(1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the number of physical flash pages that comprise a NVM page. Since NVM_DATA_SIZE_B must be a multiple of MFB_PAGE_SIZE_B, increasing the size of NVM storage should be done by modifying this define. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The total flash area consumed by NVM storage is double this value. This is due to the fact that there are two NVM pages, LEFT and RIGHT, which the algorithm alternates between. </dd></dl>

<p>Definition at line <a class="el" href="nvm_8h_source.html#l00240">240</a> of file <a class="el" href="nvm_8h_source.html">nvm.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6b9903ba1464e0fe86e356d2af171e8e"></a><!-- doxytag: member="nvm&#45;def.h::NVM_FOO_OFFSET" ref="ga6b9903ba1464e0fe86e356d2af171e8e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_FOO_OFFSET&nbsp;&nbsp;&nbsp;(NVM_MGMT_SIZE_B+0x0040)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nvm-def_8h_source.html#l00043">43</a> of file <a class="el" href="nvm-def_8h_source.html">nvm-def.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1497f4e9d097e285d60b6acea412f625"></a><!-- doxytag: member="nvm&#45;def.h::NVM_FOO_SIZE_B" ref="ga1497f4e9d097e285d60b6acea412f625" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_FOO_SIZE_B&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nvm-def_8h_source.html#l00044">44</a> of file <a class="el" href="nvm-def_8h_source.html">nvm-def.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad1aa99b6344ca133d629ce28ef198d67"></a><!-- doxytag: member="nvm&#45;def.h::NVM_HAM_OFFSET" ref="gad1aa99b6344ca133d629ce28ef198d67" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_HAM_OFFSET&nbsp;&nbsp;&nbsp;(NVM_MGMT_SIZE_B+0x0042)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nvm-def_8h_source.html#l00045">45</a> of file <a class="el" href="nvm-def_8h_source.html">nvm-def.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6c50f1148acced416b73aa2422f41457"></a><!-- doxytag: member="nvm&#45;def.h::NVM_HAM_SIZE_B" ref="ga6c50f1148acced416b73aa2422f41457" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_HAM_SIZE_B&nbsp;&nbsp;&nbsp;10</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nvm-def_8h_source.html#l00046">46</a> of file <a class="el" href="nvm-def_8h_source.html">nvm-def.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2ce94dda9f5641155bbb4eae60a7ede6"></a><!-- doxytag: member="nvm.h::NVM_LEFT_PAGE" ref="ga2ce94dda9f5641155bbb4eae60a7ede6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_LEFT_PAGE&nbsp;&nbsp;&nbsp;((<a class="el" href="group__iar.html#ga2ba8e0357fdc7b7a450e6893ed81e8e3">int32u</a>)nvmStorageLeft)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the absolute address of the LEFT page. LEFT page storage is defined by nvmStorageLeft[NVM_DATA_SIZE_B] and placed by the linker using the segment "NVM". </p>

<p>Definition at line <a class="el" href="nvm_8h_source.html#l00259">259</a> of file <a class="el" href="nvm_8h_source.html">nvm.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac8953aab91c6b245cd9c0f03fe88d4bf"></a><!-- doxytag: member="nvm.h::NVM_MGMT_SIZE_B" ref="gac8953aab91c6b245cd9c0f03fe88d4bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_MGMT_SIZE_B&nbsp;&nbsp;&nbsp;(4)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the number of bytes that comprise the NVM management bytes. All data must begin at an offset above the management bytes. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This value <b>must not change</b>. </dd></dl>

<p>Definition at line <a class="el" href="nvm_8h_source.html#l00274">274</a> of file <a class="el" href="nvm_8h_source.html">nvm.h</a>.</p>

</div>
</div>
<a class="anchor" id="gabbb742680b66285439ef9a1df5986610"></a><!-- doxytag: member="nvm&#45;def.h::NVM_RADIO_CAL_OFFSET" ref="gabbb742680b66285439ef9a1df5986610" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_RADIO_CAL_OFFSET&nbsp;&nbsp;&nbsp;(NVM_MGMT_SIZE_B+0x0000)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nvm-def_8h_source.html#l00037">37</a> of file <a class="el" href="nvm-def_8h_source.html">nvm-def.h</a>.</p>

</div>
</div>
<a class="anchor" id="gacab82da1aef071ca8ec37015ee313c4a"></a><!-- doxytag: member="nvm&#45;def.h::NVM_RADIO_CAL_SIZE_B" ref="gacab82da1aef071ca8ec37015ee313c4a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_RADIO_CAL_SIZE_B&nbsp;&nbsp;&nbsp;64</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nvm-def_8h_source.html#l00038">38</a> of file <a class="el" href="nvm-def_8h_source.html">nvm-def.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac6d032a9b1418fc2378f7dd35df05738"></a><!-- doxytag: member="nvm.h::NVM_RIGHT_PAGE" ref="gac6d032a9b1418fc2378f7dd35df05738" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_RIGHT_PAGE&nbsp;&nbsp;&nbsp;((<a class="el" href="group__iar.html#ga2ba8e0357fdc7b7a450e6893ed81e8e3">int32u</a>)nvmStorageRight)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the absolute address of the RIGHT page. RIGHT page storage is defined by nvmStorageRight[NVM_DATA_SIZE_B] and placed by the linker using the segment "NVM". </p>

<p>Definition at line <a class="el" href="nvm_8h_source.html#l00266">266</a> of file <a class="el" href="nvm_8h_source.html">nvm.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga68420abf429766d7c669d762127df736"></a><!-- doxytag: member="nvm&#45;def.h::NVM_SPAM_OFFSET" ref="ga68420abf429766d7c669d762127df736" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_SPAM_OFFSET&nbsp;&nbsp;&nbsp;(NVM_MGMT_SIZE_B+0x004C)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nvm-def_8h_source.html#l00047">47</a> of file <a class="el" href="nvm-def_8h_source.html">nvm-def.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac750f6d9cc3e1841159a63a76fc76278"></a><!-- doxytag: member="nvm&#45;def.h::NVM_SPAM_SIZE_B" ref="gac750f6d9cc3e1841159a63a76fc76278" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_SPAM_SIZE_B&nbsp;&nbsp;&nbsp;20</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nvm-def_8h_source.html#l00048">48</a> of file <a class="el" href="nvm-def_8h_source.html">nvm-def.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga75ec83fdb3880797604bbc124fc6738c"></a><!-- doxytag: member="nvm.h::halCommonGetAddressFromNvm" ref="ga75ec83fdb3880797604bbc124fc6738c" args="(int32u offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__iar.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a>* halCommonGetAddressFromNvm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iar.html#ga2ba8e0357fdc7b7a450e6893ed81e8e3">int32u</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the address of the token in NVM. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The location offset from which the address should be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address requested </dd></dl>

<p>Definition at line <a class="el" href="nvm_8c_source.html#l00134">134</a> of file <a class="el" href="nvm_8c_source.html">nvm.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga94b214413e5f6af2473a8dafc63bf350"></a><!-- doxytag: member="nvm.h::halCommonReadFromNvm" ref="ga94b214413e5f6af2473a8dafc63bf350" args="(void *data, int32u offset, int16u length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__micro.html#gafddf1f4a9c9eff790d56c8950c1fb0ad">StStatus</a> halCommonReadFromNvm </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iar.html#ga2ba8e0357fdc7b7a450e6893ed81e8e3">int32u</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iar.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a>&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy the NVM data from flash into the provided RAM location. It is illegal for the offset to be greater than NVM_DATA_SIZE_B. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A (RAM) pointer to where the data should be copied.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The location from which the data should be copied. Must be 16bit aligned.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the data in bytes. Must be 16bit aligned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An StStatus value indicating the success of the function.<ul>
<li>ST_SUCCESS if the read completed cleanly.</li>
<li>ST_ERR_FATAL if the NVM storage management indicated an invalid state. The function will return entirely 0xFF in the data parameter. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="nvm_8c_source.html#l00074">74</a> of file <a class="el" href="nvm_8c_source.html">nvm.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga2efce64dd793cbbcb56c362b5489a379"></a><!-- doxytag: member="nvm.h::halCommonWriteToNvm" ref="ga2efce64dd793cbbcb56c362b5489a379" args="(const void *data, int32u offset, int16u length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__micro.html#gafddf1f4a9c9eff790d56c8950c1fb0ad">StStatus</a> halCommonWriteToNvm </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iar.html#ga2ba8e0357fdc7b7a450e6893ed81e8e3">int32u</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iar.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a>&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write the NVM data from the provided location RAM into flash. It is illegal for the offset to be greater than NVM_DATA_SIZE_B. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A (RAM) pointer from where the data should be taken.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The location to which the data should be written. Must be 16bit aligned.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the data in bytes. Must be 16bit aligned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An StStatus value indicating the success of the function.<ul>
<li>ST_SUCCESS if the write completed cleanly.</li>
<li>Any other status value is an error code generated by the low level flash erase and write API. Refer to <a class="el" href="flash_8h.html" title="Header for flash for APIs.">flash.h</a> for details. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="nvm_8c_source.html#l00256">256</a> of file <a class="el" href="nvm_8c_source.html">nvm.c</a>.</p>

</div>
</div>
</div>
<hr size="1">

<table border="0" cellspacing="0" cellpadding="0" width=100%>

<tr>

<td><address><small>

Hardware Abstraction Layer. <br>

1.0.1.

</small></address>

</td>

<td align="right">

<address><small>

Copyright &copy; 2009 by STMicrolectronics. All rights reserved.<br>

Generated Wed Sep 1 13:42:48 2010 with <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.6.1.

</small></address>

</td>

</tr>

</table>

</body>

</html>
