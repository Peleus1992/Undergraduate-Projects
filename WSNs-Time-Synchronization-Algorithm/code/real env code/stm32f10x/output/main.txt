; generated by ARM/Thumb C/C++ Compiler with , RVCT3.1 [Build 942] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\output\main.o --depend=.\output\main.d --device=DARMSTM --apcs=interwork -O3 -I.\ -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\output\main.crf main.c]
                          THUMB

                          AREA ||i.USART_Configuration||, CODE, READONLY, ALIGN=2

                  USART_Configuration PROC
;;;201    void USART_Configuration(void)
;;;202    {
000000  b530              PUSH     {r4,r5,lr}
000002  b087              SUB      sp,sp,#0x1c
;;;203      USART_InitTypeDef USART_InitStructure;
;;;204      USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;205    /* USART1 configuration -----------------------------------------------
;;;206    
;;;207    -------*/
;;;208      /* USART1 configured as follow:
;;;209            - BaudRate = 115200 baud  
;;;210            - Word Length = 8 Bits
;;;211            - One Stop Bit
;;;212            - No parity
;;;213            - Hardware flow control disabled (RTS and CTS signals)
;;;214            - Receive and transmit enabled
;;;215            - USART Clock disabled
;;;216            - USART CPOL: Clock is active low
;;;217            - USART CPHA: Data is captured on the middle 
;;;218            - USART LastBit: The clock pulse of the last data bit is not 
;;;219    
;;;220    output to 
;;;221                             the SCLK pin
;;;222      */
;;;223    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
000004  2400              MOVS     r4,#0
;;;224    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
;;;225    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
000006  f44f7000          MOV      r0,#0x200
00000a  f8ad0008          STRH     r0,[sp,#8]
;;;226    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
;;;227    /* Configure the USART1 synchronous paramters */
;;;228    USART_ClockInit(USART1, &USART_ClockInitStructure);
00000e  4d11              LDR      r5,|L1.84|
000010  f8ad4004          STRH     r4,[sp,#4]            ;223
000014  f8ad4006          STRH     r4,[sp,#6]            ;224
000018  f8ad400a          STRH     r4,[sp,#0xa]          ;226
00001c  a901              ADD      r1,sp,#4
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       USART_ClockInit
;;;229    
;;;230    USART_InitStructure.USART_BaudRate = 115200;
000024  f44f30e1          MOV      r0,#0x1c200
;;;231    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000028  9003              STR      r0,[sp,#0xc]
;;;232    USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;233    USART_InitStructure.USART_Parity = USART_Parity_No ;
00002a  f8ad4014          STRH     r4,[sp,#0x14]
;;;234    USART_InitStructure.USART_HardwareFlowControl = 
;;;235    
;;;236    USART_HardwareFlowControl_None;
;;;237    
;;;238    
;;;239    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00002e  200c              MOVS     r0,#0xc
000030  f8ad4010          STRH     r4,[sp,#0x10]         ;231
000034  f8ad0016          STRH     r0,[sp,#0x16]
000038  f8ad4012          STRH     r4,[sp,#0x12]         ;232
00003c  f8ad4018          STRH     r4,[sp,#0x18]         ;234
;;;240    /* Configure USART1 basic and asynchronous paramters */
;;;241    USART_Init(USART1, &USART_InitStructure);
000040  a903              ADD      r1,sp,#0xc
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       USART_Init
;;;242        
;;;243      /* Enable USART1 */
;;;244      USART_Cmd(USART1, ENABLE);
000048  2101              MOVS     r1,#1
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       USART_Cmd
;;;245    }
000050  b007              ADD      sp,sp,#0x1c
000052  bd30              POP      {r4,r5,pc}
;;;246    
                          ENDP

                  |L1.84|
000054  40013800          DCD      0x40013800

                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;143    void GPIO_Configuration(void)
;;;144    {
000000  b538              PUSH     {r3-r5,lr}
;;;145      GPIO_InitTypeDef GPIO_InitStructure;
;;;146        
;;;147      /* Configure PC13 as input floating (EXTI Line13) */
;;;148      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000002  2003              MOVS     r0,#3
000004  f88d0002          STRB     r0,[sp,#2]
;;;149      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
000008  f44f5000          MOV      r0,#0x2000
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;150      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000010  2404              MOVS     r4,#4
000012  f88d4003          STRB     r4,[sp,#3]
;;;151      GPIO_Init(GPIOC, &GPIO_InitStructure);
000016  4669              MOV      r1,sp
000018  480b              LDR      r0,|L2.72|
00001a  f7fffffe          BL       GPIO_Init
;;;152    
;;;153      /* Configure USART1 Tx (PA.9) as alternate function push-pull */
;;;154      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00001e  01e0              LSLS     r0,r4,#7
000020  f8ad0000          STRH     r0,[sp,#0]
;;;155      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000024  2018              MOVS     r0,#0x18
;;;156      GPIO_Init(GPIOA, &GPIO_InitStructure);
000026  4d09              LDR      r5,|L2.76|
000028  f88d0003          STRB     r0,[sp,#3]            ;155
00002c  4669              MOV      r1,sp
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       GPIO_Init
;;;157        
;;;158      /* Configure USART1 Rx (PA.10) as input floating */
;;;159      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000034  0220              LSLS     r0,r4,#8
000036  f8ad0000          STRH     r0,[sp,#0]
;;;160      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003a  f88d4003          STRB     r4,[sp,#3]
;;;161      GPIO_Init(GPIOA, &GPIO_InitStructure);
00003e  4669              MOV      r1,sp
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       GPIO_Init
;;;162    }
000046  bd38              POP      {r3-r5,pc}
;;;163    
                          ENDP

                  |L2.72|
000048  40011000          DCD      0x40011000
                  |L2.76|
00004c  40010800          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
000000  b508              PUSH     {r3,lr}
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
00000c  f44f60c0          MOV      r0,#0x600
000010  f7fffffe          BL       NVIC_PriorityGroupConfig
000014  2028              MOVS     r0,#0x28
000016  f88d0000          STRB     r0,[sp,#0]
00001a  2000              MOVS     r0,#0
00001c  f88d0001          STRB     r0,[sp,#1]
000020  f88d0002          STRB     r0,[sp,#2]
000024  2001              MOVS     r0,#1
000026  f88d0003          STRB     r0,[sp,#3]
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       NVIC_Init
000030  bd08              POP      {r3,pc}
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;85     void RCC_Configuration(void)
;;;86     {
000000  b510              PUSH     {r4,lr}
;;;87       /* RCC system reset(for debug purpose) */
;;;88       RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;89     
;;;90       /* Enable HSE */
;;;91       RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3480          MOV      r4,#0x10000
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RCC_HSEConfig
;;;92     
;;;93       /* Wait till HSE is ready */
;;;94       HSEStartUpStatus = RCC_WaitForHSEStartUp();
000010  f7fffffe          BL       RCC_WaitForHSEStartUp
000014  4917              LDR      r1,|L4.116|
000016  7008              STRB     r0,[r1,#0]  ; HSEStartUpStatus
;;;95     
;;;96       if(HSEStartUpStatus == SUCCESS)
000018  b2c0              UXTB     r0,r0
00001a  2801              CMP      r0,#1
00001c  d122              BNE      |L4.100|
;;;97       {
;;;98         /* HCLK = SYSCLK */
;;;99         RCC_HCLKConfig(RCC_SYSCLK_Div1); 
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       RCC_HCLKConfig
;;;100      
;;;101        /* PCLK2 = HCLK */
;;;102        RCC_PCLK2Config(RCC_HCLK_Div1); 
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       RCC_PCLK2Config
;;;103    
;;;104        /* PCLK1 = HCLK/2 */
;;;105        RCC_PCLK1Config(RCC_HCLK_Div2);
00002a  11a0              ASRS     r0,r4,#6
00002c  f7fffffe          BL       RCC_PCLK1Config
;;;106    
;;;107        /* Flash 2 wait state */
;;;108        FLASH_SetLatency(FLASH_Latency_2);
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       FLASH_SetLatency
;;;109        /* Enable Prefetch Buffer */
;;;110        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
000036  2010              MOVS     r0,#0x10
000038  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;111    
;;;112        /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;113        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
00003c  f44f11e0          MOV      r1,#0x1c0000
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       RCC_PLLConfig
;;;114    
;;;115        /* Enable PLL */ 
;;;116        RCC_PLLCmd(ENABLE);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       RCC_PLLCmd
                  |L4.76|
;;;117    
;;;118        /* Wait till PLL is ready */
;;;119        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
00004c  2039              MOVS     r0,#0x39
00004e  f7fffffe          BL       RCC_GetFlagStatus
000052  2800              CMP      r0,#0
000054  d0fa              BEQ      |L4.76|
;;;120        {
;;;121        }
;;;122    
;;;123        /* Select PLL as system clock source */
;;;124        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
000056  2002              MOVS     r0,#2
000058  f7fffffe          BL       RCC_SYSCLKConfig
                  |L4.92|
;;;125    
;;;126        /* Wait till PLL is used as system clock source */
;;;127        while(RCC_GetSYSCLKSource() != 0x08)
00005c  f7fffffe          BL       RCC_GetSYSCLKSource
000060  2808              CMP      r0,#8
000062  d1fb              BNE      |L4.92|
                  |L4.100|
;;;128        {
;;;129        }
;;;130      }
;;;131       
;;;132      /* Enable GPIOA, GPIOC,USART1 and AFIO clock */
;;;133      RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOC| RCC_APB2Periph_AFIO|RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);
000064  e8bd4010          POP      {r4,lr}
000068  2101              MOVS     r1,#1
00006a  f2440015          MOV      r0,#0x4015
00006e  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
;;;134    }
;;;135    
                          ENDP

000072  0000              DCW      0x0000
                  |L4.116|
000074  00000000          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;44     int main(void)
;;;45     {
000000  b510              PUSH     {r4,lr}
;;;46     #ifdef DEBUG
;;;47       debug();
;;;48     #endif
;;;49       
;;;50       /* System Clocks Configuration */
;;;51       RCC_Configuration();
000002  f7fffffe          BL       RCC_Configuration
;;;52            
;;;53       /* NVIC configuration */
;;;54       NVIC_Configuration();
000006  f7fffffe          BL       NVIC_Configuration
;;;55         
;;;56       /* Configure the GPIO ports */
;;;57       GPIO_Configuration();
00000a  f7fffffe          BL       GPIO_Configuration
;;;58       USART_Configuration(); 
00000e  f7fffffe          BL       USART_Configuration
;;;59       printf(" System boot success!\n");
000012  a00b              ADR      r0,|L5.64|
000014  f7fffffe          BL       __1printf
;;;60       /* Connect EXTI Line13 to PC.13 */
;;;61       GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource13);
000018  210d              MOVS     r1,#0xd
00001a  2002              MOVS     r0,#2
00001c  f7fffffe          BL       GPIO_EXTILineConfig
;;;62     
;;;63       /* Configure EXTI Line13 to generate an interrupt on falling edge */  
;;;64       EXTI_InitStructure.EXTI_Line = EXTI_Line13;
000020  480d              LDR      r0,|L5.88|
000022  f44f5400          MOV      r4,#0x2000
;;;65       EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
000026  2100              MOVS     r1,#0
000028  6004              STR      r4,[r0,#0]  ; EXTI_InitStructure
00002a  7101              STRB     r1,[r0,#4]  ; EXTI_InitStructure
;;;66       EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
00002c  210c              MOVS     r1,#0xc
00002e  7141              STRB     r1,[r0,#5]  ; EXTI_InitStructure
;;;67       EXTI_InitStructure.EXTI_LineCmd = ENABLE;
000030  2101              MOVS     r1,#1
000032  7181              STRB     r1,[r0,#6]  ; EXTI_InitStructure
;;;68       EXTI_Init(&EXTI_InitStructure);
000034  f7fffffe          BL       EXTI_Init
;;;69     
;;;70       /* Generate software interrupt: simulate a falling edge applied on EXTI line 13 */
;;;71       EXTI_GenerateSWInterrupt(EXTI_Line13);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       EXTI_GenerateSWInterrupt
                  |L5.62|
;;;72             
;;;73       while (1)
00003e  e7fe              B        |L5.62|
;;;74       {
;;;75       }
;;;76     }
;;;77     
                          ENDP

                  |L5.64|
000040  2053797374656d20626f6f742073756363657373210a00        DCB      " System boot success!\n",0
000057  00                DCB      0
                  |L5.88|
000058  00000004          DCD      ||.data||+0x4

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;255    int fputc(int ch, FILE *f)
;;;256    {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;257    #ifdef DBG_ITM
;;;258    /* 将Printf内容发往ITM激励寄存器端口  */
;;;259      if (DEMCR & TRCENA) {
;;;260        while (ITM_Port32(0) == 0);
;;;261        ITM_Port8(0) = ch;
;;;262      }
;;;263    #else  
;;;264    /* 将Printf内容发往串口 */
;;;265      USART_SendData(USART1, (unsigned char) ch);
000004  b2c1              UXTB     r1,r0
000006  4805              LDR      r0,|L6.28|
000008  f7fffffe          BL       USART_SendData
00000c  4804              LDR      r0,|L6.32|
;;;266      while (!(USART1->SR & USART_FLAG_TXE));
00000e  bf00              NOP      
                  |L6.16|
000010  f8b01800          LDRH     r1,[r0,#0x800]
000014  0609              LSLS     r1,r1,#24
000016  d5fb              BPL      |L6.16|
;;;267    #endif  
;;;268      return (ch);
000018  4620              MOV      r0,r4
;;;269    }
00001a  bd10              POP      {r4,pc}
;;;270    
                          ENDP

                  |L6.28|
00001c  40013800          DCD      0x40013800
                  |L6.32|
000020  40013000          DCD      0x40013000

                          AREA ||.data||, DATA, ALIGN=2

                  HSEStartUpStatus
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  EXTI_InitStructure
                          %        8

                  __ARM_use_no_argv EQU 0
