; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\main.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\output\main.d --cpu=Cortex-M3 --apcs=interwork -O3 -I. -I"G:\Peleus_Program Files\Keil\ARM\RV31\Inc" -I"G:\Peleus_Program Files\Keil\ARM\CMSIS\Include" -I"G:\Peleus_Program Files\Keil\ARM\Inc\ST\STM32F10x" --omf_browse=.\output\main.crf main.c]
                          THUMB

                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;142    *******************************************************************************/
;;;143    void GPIO_Configuration(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;144    {
;;;145      GPIO_InitTypeDef GPIO_InitStructure;
;;;146        
;;;147      /* Configure PC13 as input floating (EXTI Line13) */
;;;148      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000002  2503              MOVS     r5,#3
000004  f88d5002          STRB     r5,[sp,#2]
;;;149      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
000008  f44f5600          MOV      r6,#0x2000
;;;150      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;151      GPIO_Init(GPIOC, &GPIO_InitStructure);
00000c  4f30              LDR      r7,|L1.208|
00000e  f8ad6000          STRH     r6,[sp,#0]            ;149
000012  2404              MOVS     r4,#4                 ;150
000014  f88d4003          STRB     r4,[sp,#3]            ;150
000018  4669              MOV      r1,sp
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       GPIO_Init
;;;152    
;;;153      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
000020  2002              MOVS     r0,#2
000022  f8ad0000          STRH     r0,[sp,#0]
;;;154      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000026  f88d4003          STRB     r4,[sp,#3]
;;;155      GPIO_Init(GPIOC, &GPIO_InitStructure);
00002a  4669              MOV      r1,sp
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       GPIO_Init
;;;156    
;;;157      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000032  f8ad4000          STRH     r4,[sp,#0]
;;;158      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000036  f88d4003          STRB     r4,[sp,#3]
;;;159      GPIO_Init(GPIOC, &GPIO_InitStructure);
00003a  4669              MOV      r1,sp
00003c  4638              MOV      r0,r7
00003e  f7fffffe          BL       GPIO_Init
;;;160      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000042  f88d5002          STRB     r5,[sp,#2]
;;;161      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
000046  f8ad6000          STRH     r6,[sp,#0]
;;;162      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00004a  f88d4003          STRB     r4,[sp,#3]
;;;163      GPIO_Init(GPIOC, &GPIO_InitStructure);
00004e  4669              MOV      r1,sp
000050  4638              MOV      r0,r7
000052  f7fffffe          BL       GPIO_Init
;;;164      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000056  f88d5002          STRB     r5,[sp,#2]
;;;165      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
00005a  f8ad6000          STRH     r6,[sp,#0]
;;;166      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00005e  f88d4003          STRB     r4,[sp,#3]
;;;167      GPIO_Init(GPIOC, &GPIO_InitStructure);
000062  4669              MOV      r1,sp
000064  4638              MOV      r0,r7
000066  f7fffffe          BL       GPIO_Init
;;;168      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00006a  f88d5002          STRB     r5,[sp,#2]
;;;169      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
00006e  f8ad6000          STRH     r6,[sp,#0]
;;;170      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000072  f88d4003          STRB     r4,[sp,#3]
;;;171      GPIO_Init(GPIOC, &GPIO_InitStructure);
000076  4669              MOV      r1,sp
000078  4638              MOV      r0,r7
00007a  f7fffffe          BL       GPIO_Init
;;;172      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00007e  f88d5002          STRB     r5,[sp,#2]
;;;173      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
000082  f8ad6000          STRH     r6,[sp,#0]
;;;174      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000086  f88d4003          STRB     r4,[sp,#3]
;;;175      GPIO_Init(GPIOC, &GPIO_InitStructure);
00008a  4669              MOV      r1,sp
00008c  4638              MOV      r0,r7
00008e  f7fffffe          BL       GPIO_Init
;;;176      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000092  f88d5002          STRB     r5,[sp,#2]
;;;177      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
000096  f8ad6000          STRH     r6,[sp,#0]
;;;178      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00009a  f88d4003          STRB     r4,[sp,#3]
;;;179      GPIO_Init(GPIOC, &GPIO_InitStructure);
00009e  4669              MOV      r1,sp
0000a0  4638              MOV      r0,r7
0000a2  f7fffffe          BL       GPIO_Init
;;;180    
;;;181      /* Configure USART1 Tx (PA.9) as alternate function push-pull */
;;;182      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
0000a6  01e0              LSLS     r0,r4,#7
0000a8  f8ad0000          STRH     r0,[sp,#0]
;;;183      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
0000ac  2018              MOVS     r0,#0x18
;;;184      GPIO_Init(GPIOA, &GPIO_InitStructure);
0000ae  4d09              LDR      r5,|L1.212|
0000b0  f88d0003          STRB     r0,[sp,#3]            ;183
0000b4  4669              MOV      r1,sp
0000b6  4628              MOV      r0,r5
0000b8  f7fffffe          BL       GPIO_Init
;;;185        
;;;186      /* Configure USART1 Rx (PA.10) as input floating */
;;;187      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
0000bc  0220              LSLS     r0,r4,#8
0000be  f8ad0000          STRH     r0,[sp,#0]
;;;188      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0000c2  f88d4003          STRB     r4,[sp,#3]
;;;189      GPIO_Init(GPIOA, &GPIO_InitStructure);
0000c6  4669              MOV      r1,sp
0000c8  4628              MOV      r0,r5
0000ca  f7fffffe          BL       GPIO_Init
;;;190    }
0000ce  bdf8              POP      {r3-r7,pc}
;;;191    
                          ENDP

                  |L1.208|
                          DCD      0x40011000
                  |L1.212|
                          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;198    *******************************************************************************/
;;;199    void NVIC_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;200    {
;;;201      NVIC_InitTypeDef NVIC_InitStructure;
;;;202      
;;;203    #ifdef  VECT_TAB_RAM  
;;;204      /* Set the Vector Table base location at 0x20000000 */ 
;;;205      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
;;;206    #else  /* VECT_TAB_FLASH  */
;;;207      /* Set the Vector Table base location at 0x08000000 */ 
;;;208      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
;;;209    #endif
;;;210    
;;;211      /* Configure one bit for preemption priority */
;;;212      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
00000c  f44f60c0          MOV      r0,#0x600
000010  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;213      
;;;214      /* Enable the EXTI15_10 Interrupt */
;;;215      NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQChannel;
000014  2028              MOVS     r0,#0x28
000016  f88d0000          STRB     r0,[sp,#0]
;;;216      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00001a  2000              MOVS     r0,#0
00001c  f88d0001          STRB     r0,[sp,#1]
;;;217      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000020  f88d0002          STRB     r0,[sp,#2]
;;;218      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000024  2001              MOVS     r0,#1
000026  f88d0003          STRB     r0,[sp,#3]
;;;219      NVIC_Init(&NVIC_InitStructure);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       NVIC_Init
;;;220    }
000030  bd08              POP      {r3,pc}
;;;221    
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;84     *******************************************************************************/
;;;85     void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;86     {
;;;87       /* RCC system reset(for debug purpose) */
;;;88       RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;89     
;;;90       /* Enable HSE */
;;;91       RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3480          MOV      r4,#0x10000
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RCC_HSEConfig
;;;92     
;;;93       /* Wait till HSE is ready */
;;;94       HSEStartUpStatus = RCC_WaitForHSEStartUp();
000010  f7fffffe          BL       RCC_WaitForHSEStartUp
000014  4917              LDR      r1,|L3.116|
;;;95     
;;;96       if(HSEStartUpStatus == SUCCESS)
000016  2801              CMP      r0,#1
000018  7008              STRB     r0,[r1,#0]            ;94
00001a  d123              BNE      |L3.100|
;;;97       {
;;;98         /* HCLK = SYSCLK */
;;;99         RCC_HCLKConfig(RCC_SYSCLK_Div1); 
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       RCC_HCLKConfig
;;;100      
;;;101        /* PCLK2 = HCLK */
;;;102        RCC_PCLK2Config(RCC_HCLK_Div1); 
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       RCC_PCLK2Config
;;;103    
;;;104        /* PCLK1 = HCLK/2 */
;;;105        RCC_PCLK1Config(RCC_HCLK_Div2);
000028  11a0              ASRS     r0,r4,#6
00002a  f7fffffe          BL       RCC_PCLK1Config
;;;106    
;;;107        /* Flash 2 wait state */
;;;108        FLASH_SetLatency(FLASH_Latency_2);
00002e  2002              MOVS     r0,#2
000030  f7fffffe          BL       FLASH_SetLatency
;;;109        /* Enable Prefetch Buffer */
;;;110        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
000034  2010              MOVS     r0,#0x10
000036  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;111    
;;;112        /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;113        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
00003a  f44f11e0          MOV      r1,#0x1c0000
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       RCC_PLLConfig
;;;114    
;;;115        /* Enable PLL */ 
;;;116        RCC_PLLCmd(ENABLE);
000044  2001              MOVS     r0,#1
000046  f7fffffe          BL       RCC_PLLCmd
                  |L3.74|
;;;117    
;;;118        /* Wait till PLL is ready */
;;;119        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
00004a  2039              MOVS     r0,#0x39
00004c  f7fffffe          BL       RCC_GetFlagStatus
000050  2800              CMP      r0,#0
000052  d0fa              BEQ      |L3.74|
;;;120        {
;;;121        }
;;;122    
;;;123        /* Select PLL as system clock source */
;;;124        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
000054  2002              MOVS     r0,#2
000056  f7fffffe          BL       RCC_SYSCLKConfig
;;;125    
;;;126        /* Wait till PLL is used as system clock source */
;;;127        while(RCC_GetSYSCLKSource() != 0x08)
00005a  bf00              NOP      
                  |L3.92|
00005c  f7fffffe          BL       RCC_GetSYSCLKSource
000060  2808              CMP      r0,#8
000062  d1fb              BNE      |L3.92|
                  |L3.100|
;;;128        {
;;;129        }
;;;130      }
;;;131       
;;;132      /* Enable GPIOA, GPIOC,USART1 and AFIO clock */
;;;133      RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOC| RCC_APB2Periph_AFIO|RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);
000064  e8bd4010          POP      {r4,lr}
000068  2101              MOVS     r1,#1
00006a  f2440015          MOV      r0,#0x4015
00006e  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
;;;134    }
;;;135    
                          ENDP

000072  0000              DCW      0x0000
                  |L3.116|
                          DCD      ||.data||

                          AREA ||i.USART_Configuration||, CODE, READONLY, ALIGN=2

                  USART_Configuration PROC
;;;228    *******************************************************************************/
;;;229    void USART_Configuration(void)
000000  b530              PUSH     {r4,r5,lr}
;;;230    {
000002  b087              SUB      sp,sp,#0x1c
;;;231      USART_InitTypeDef USART_InitStructure;
;;;232      USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;233    /* USART1 configuration -----------------------------------------------
;;;234    
;;;235    -------*/
;;;236      /* USART1 configured as follow:
;;;237            - BaudRate = 115200 baud  
;;;238            - Word Length = 8 Bits
;;;239            - One Stop Bit
;;;240            - No parity
;;;241            - Hardware flow control disabled (RTS and CTS signals)
;;;242            - Receive and transmit enabled
;;;243            - USART Clock disabled
;;;244            - USART CPOL: Clock is active low
;;;245            - USART CPHA: Data is captured on the middle 
;;;246            - USART LastBit: The clock pulse of the last data bit is not 
;;;247    
;;;248    output to 
;;;249                             the SCLK pin
;;;250      */
;;;251    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
000004  2400              MOVS     r4,#0
;;;252    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
;;;253    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
000006  f44f7000          MOV      r0,#0x200
00000a  f8ad0014          STRH     r0,[sp,#0x14]
;;;254    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
;;;255    /* Configure the USART1 synchronous paramters */
;;;256    USART_ClockInit(USART1, &USART_ClockInitStructure);
00000e  4d11              LDR      r5,|L4.84|
000010  f8ad4010          STRH     r4,[sp,#0x10]         ;251
000014  f8ad4012          STRH     r4,[sp,#0x12]         ;252
000018  f8ad4016          STRH     r4,[sp,#0x16]         ;254
00001c  a904              ADD      r1,sp,#0x10
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       USART_ClockInit
;;;257    
;;;258    USART_InitStructure.USART_BaudRate = 115200;
000024  f44f30e1          MOV      r0,#0x1c200
;;;259    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000028  9000              STR      r0,[sp,#0]
;;;260    USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;261    USART_InitStructure.USART_Parity = USART_Parity_No ;
00002a  f8ad4008          STRH     r4,[sp,#8]
;;;262    USART_InitStructure.USART_HardwareFlowControl = 
;;;263    
;;;264    USART_HardwareFlowControl_None;
;;;265    
;;;266    
;;;267    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00002e  200c              MOVS     r0,#0xc
000030  f8ad4004          STRH     r4,[sp,#4]            ;259
000034  f8ad000a          STRH     r0,[sp,#0xa]
000038  f8ad4006          STRH     r4,[sp,#6]            ;260
00003c  f8ad400c          STRH     r4,[sp,#0xc]          ;262
;;;268    /* Configure USART1 basic and asynchronous paramters */
;;;269    USART_Init(USART1, &USART_InitStructure);
000040  4669              MOV      r1,sp
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       USART_Init
;;;270        
;;;271      /* Enable USART1 */
;;;272      USART_Cmd(USART1, ENABLE);
000048  2101              MOVS     r1,#1
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       USART_Cmd
;;;273    }
000050  b007              ADD      sp,sp,#0x1c
000052  bd30              POP      {r4,r5,pc}
;;;274    
                          ENDP

                  |L4.84|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;282    
;;;283    int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;284    {
;;;285    #ifdef DBG_ITM
;;;286    /* 将Printf内容发往ITM激励寄存器端口  */
;;;287      if (DEMCR & TRCENA) {
;;;288        while (ITM_Port32(0) == 0);
;;;289        ITM_Port8(0) = ch;
;;;290      }
;;;291    #else  
;;;292    /* 将Printf内容发往串口 */
;;;293      USART_SendData(USART1, (unsigned char) ch);
000002  4d05              LDR      r5,|L5.24|
000004  4604              MOV      r4,r0                 ;284
000006  b2c1              UXTB     r1,r0
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       USART_SendData
                  |L5.14|
;;;294      while (!(USART1->SR & USART_FLAG_TXE));
00000e  8828              LDRH     r0,[r5,#0]
000010  0600              LSLS     r0,r0,#24
000012  d5fc              BPL      |L5.14|
;;;295    #endif  
;;;296      return (ch);
000014  4620              MOV      r0,r4
;;;297    }
000016  bd70              POP      {r4-r6,pc}
;;;298    
                          ENDP

                  |L5.24|
                          DCD      0x40013800

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;43     *******************************************************************************/
;;;44     int main(void)
000000  f7fffffe          BL       RCC_Configuration
;;;45     {
;;;46     #ifdef DEBUG
;;;47       debug();
;;;48     #endif
;;;49       
;;;50       /* System Clocks Configuration */
;;;51       RCC_Configuration();
;;;52            
;;;53       /* NVIC configuration */
;;;54       NVIC_Configuration();
000004  f7fffffe          BL       NVIC_Configuration
;;;55         
;;;56       /* Configure the GPIO ports */
;;;57       GPIO_Configuration();
000008  f7fffffe          BL       GPIO_Configuration
;;;58       USART_Configuration(); 
00000c  f7fffffe          BL       USART_Configuration
;;;59       printf(" System boot success!\n");
000010  a00b              ADR      r0,|L6.64|
000012  f7fffffe          BL       __2printf
;;;60       /* Connect EXTI Line13 to PC.13 */
;;;61       GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource13);
000016  210d              MOVS     r1,#0xd
000018  2002              MOVS     r0,#2
00001a  f7fffffe          BL       GPIO_EXTILineConfig
;;;62     
;;;63       /* Configure EXTI Line13 to generate an interrupt on falling edge */  
;;;64       EXTI_InitStructure.EXTI_Line = EXTI_Line13;
00001e  490e              LDR      r1,|L6.88|
000020  f44f5400          MOV      r4,#0x2000
;;;65       EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
000024  2000              MOVS     r0,#0
000026  600c              STR      r4,[r1,#0]  ; EXTI_InitStructure
000028  7108              STRB     r0,[r1,#4]
;;;66       EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
00002a  200c              MOVS     r0,#0xc
00002c  7148              STRB     r0,[r1,#5]
;;;67       EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00002e  2001              MOVS     r0,#1
000030  7188              STRB     r0,[r1,#6]
;;;68       EXTI_Init(&EXTI_InitStructure);
000032  4608              MOV      r0,r1
000034  f7fffffe          BL       EXTI_Init
;;;69     
;;;70       /* Generate software interrupt: simulate a falling edge applied on EXTI line 13 */
;;;71       EXTI_GenerateSWInterrupt(EXTI_Line13);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       EXTI_GenerateSWInterrupt
                  |L6.62|
;;;72             
;;;73       while (1)
00003e  e7fe              B        |L6.62|
;;;74       {
;;;75       }
;;;76     }
;;;77     
                          ENDP

                  |L6.64|
000040  20537973          DCB      " System boot success!\n",0
000044  74656d20
000048  626f6f74
00004c  20737563
000050  63657373
000054  210a00  
000057  00                DCB      0
                  |L6.88|
                          DCD      ||.data||+0x4

                          AREA ||.data||, DATA, ALIGN=2

                  HSEStartUpStatus
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  EXTI_InitStructure
                          %        8

                  __ARM_use_no_argv EQU 0
